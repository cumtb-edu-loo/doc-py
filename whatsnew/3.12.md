# Python 3.12 有什么新变化¶

Editor:

    

~~~
TBD

本文介绍了 Python 3.12 相比 3.11 的新增特性。

更详细的信息可参阅 [更新日志](changelog.md#changelog)。

备注

预发布版用户应当了解到此文档目前处于草稿状态。 它将随着 Python 3.12 的发布进行不断更新，因此即使已经阅读过较早的版本也仍然值得再次查看。

## 摘要 -- 发布重点¶

新的语法特性：

  * PEP 701：f-字符串的句法形式化

解释器的改进：

  * PEP 684: 解释器级 GIL

  * PEP 669：针对 CPython 的低影响监控

新的类型标注特性：

  * PEP 688: 使缓冲区协议在Python中可访问

  * PEP 692: 使用 TypedDict 进行更精确的 **kwargs 类型标注

  * PEP 695: 类型形参语法

  * PEP 698：覆盖静态类型的装饰器

重要的弃用、移除或限制：

  * [**PEP 623**](https://peps.python.org/pep-0623/): 从 Unicode 中移除 wstr

  * [**PEP 632**](https://peps.python.org/pep-0632/): 移除 `distutils` 包。 请参阅 [the migration guide](https://peps.python.org/pep-0632/#migration-advice) 了解其替代品的建议。

## 改进的错误消息¶

  * 当引发的 [`NameError`](../library/exceptions.md#NameError "NameError") 被传播至顶级时，解释器显示的错误消息可能将标准库中的模块作为建议的一部分。由 Pablo Galindo 在 [gh-98254](https://github.com/python/cpython/issues/98254) 中贡献。
    
        >>> sys.version_info
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'sys' is not defined. Did you forget to import 'sys'?
~~~

  * 改进实例的 [`NameError`](../library/exceptions.md#NameError "NameError") 异常的错误建议。现在，如果在方法中引发了 [`NameError`](../library/exceptions.md#NameError "NameError") ，并且实例具有与异常中的名称完全相等的属性，则建议将包括 `self.<NAME>` ，而不是方法范围中最接近的匹配项。由 Pablo Galindo 在 [gh-99139](https://github.com/python/cpython/issues/99139) 中贡献。
    
        >>> class A:
    ...    def __init__(self):
    ...        self.blech = 1
    ...
    ...    def foo(self):
    ...        somethin = blech
    
    
        >>> A().foo()
    Traceback (most recent call last):
      File "<stdin>", line 1
        somethin = blech
                   ^^^^^
    NameError: name 'blech' is not defined. Did you mean: 'self.blech'?
    

  * 改进了使用 `import x from y` 而不是 `from y import x` 时产生的 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError") 错误消息。由 Pablo Galindo 在 [gh-98931](https://github.com/python/cpython/issues/98931) 中贡献。
    
        >>> import a.y.z from b.y.z
    Traceback (most recent call last):
      File "<stdin>", line 1
        import a.y.z from b.y.z
        ^^^^^^^^^^^^^^^^^^^^^^^
    SyntaxError: Did you mean to use 'from ... import ...' instead?
    

  * 从失败的 `from <module> import <name>` 语句引发的 [`ImportError`](../library/exceptions.md#ImportError "ImportError") 异常现在包括基于 `<module>` 中可用名称的 `<name>` 值的建议。由 Pablo Galindo 在 [gh-91058](https://github.com/python/cpython/issues/91058) 中贡献。
    
        >>> from collections import chainmap
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ImportError: cannot import name 'chainmap' from 'collections'. Did you mean: 'ChainMap'?
    

## 新的特性¶

### PEP 701：f-字符串的句法形式化¶

[**PEP 701**](https://peps.python.org/pep-0701/) 取消了对f-字符串使用的一些限制。f-字符串中的表达式组件现在可以是任何有效的Python表达式，包括反斜杠、unicode转义序列、多行表达式、注释和与包含的f-字符串重复使用相同引号的字符串。让我们详细介绍一下：

  * 引号重用：在 Python 3.11 及以前，重用与包含的f-字符串相同的引号会引发 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError") ，迫使用户使用其他可用的引号（例如，如果f-字符串使用单引号，则使用双引号或三引号）。在 Python 3.12 中，你现在可以执行以下操作：
    
        >>> songs = ['Take me back to Eden', 'Alkaline', 'Ascensionism']
    >>> f"This is the playlist: {", ".join(songs)}"
    'This is the playlist: Take me back to Eden, Alkaline, Ascensionism'
    

请注意，在这一更改之前，对f-字符串的嵌套方式没有明确的限制，但字符串引号不能在f-字符串的表达式组件中重复使用，这使得不可能任意嵌套f-字符串。事实上，这是可以编写的嵌套最多的f-字符串：

    
        >>> f"""{f'''{f'{f"{1+1}"}'}'''}"""
    '2'
    

由于现在f-字符串可以在表达式组件中包含任何有效的Python表达式，因此现在可以任意嵌套f-字符串：

    
        >>> f"{f"{f"{f"{f"{f"{1+1}"}"}"}"}"}"
    '2'
    

  * 多行表达式和注释：在Python 3.11中，f-字符串表达式必须在一行中定义，即使外部f-字符串表达式可能跨越多行（就像在多行上定义的字面值列表一样），也会使它们更难阅读。在Python 3.12中，你现在可以定义跨越多行的表达式，并在其中包含注释：
    
        >>> f"This is the playlist: {", ".join([
    ...     'Take me back to Eden',  # My, my, those eyes like fire
    ...     'Alkaline',              # Not acid nor alkaline
    ...     'Ascensionism'           # Take to the broken skies at last
    ... ])}"
    'This is the playlist: Take me back to Eden, Alkaline, Ascensionism'
    

  * 反斜杠和unicode字符：在Python 3.12之前，f-字符串表达式不能包含任何 `\` 字符。这也影响了 unicode 转义序列 (如 `\N{snowman}`)，因为这些序列包含 `\N` 部分，而这些部分以前不能作为f-字符串的表达式组件的一部分。现在，你可以定义如下表达式:
    
        >>> print(f"This is the playlist: {"\n".join(songs)}")
    This is the playlist: Take me back to Eden
    Alkaline
    Ascensionism
    >>> print(f"This is the playlist: {"\N{BLACK HEART SUIT}".join(songs)}")
    This is the playlist: Take me back to Eden♥Alkaline♥Ascensionism
    

更多细节请参见 [**PEP 701**](https://peps.python.org/pep-0701/)。

作为实现此功能的正面影响 (通过使用 PEG 解析器解析 f 字符串，参见 [**PEP 617**](https://peps.python.org/pep-0617/))，现在 f 字符串的错误消息更加精确，包括错误的确切位置。 例如，在 Python 3.11 中，以下 f 字符串引发一个 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError"):

    
    
~~~shell
>>> my_string = f"{x z y}" + f"{1 + 1}"
  File "<stdin>", line 1
    (x z y)
     ^^^
SyntaxError: f-string: invalid syntax. Perhaps you forgot a comma?
~~~

但是错误消息不包括错误在行中的确切位置，而且表达式被人为地用括号括起来。在Python 3.12中，由于f-字符串是用PEG解析器解析的，因此错误消息可以更精确，并显示整行：

    
    
~~~shell
>>> my_string = f"{x z y}" + f"{1 + 1}"
  File "<stdin>", line 1
    my_string = f"{x z y}" + f"{1 + 1}"
                   ^^^
SyntaxError: invalid syntax. Perhaps you forgot a comma?
~~~

（由 Pablo Galindo、Batuhan Taskaya、 Lysandros Nikolaou、Cristián Maureira-Fredes 和 Marta Gómez 在 [gh-102856](https://github.com/python/cpython/issues/102856) 中贡献。 PEP 由 Pablo Galindo、 Batuhan Taskaya、 Lysandros Nikolaou 和 Marta Gómez 撰写）。

### PEP 709：推导式内联¶

字典、列表和集合推导式现在是内联的，而不是为每次执行推导式创建一个新的一次性函数对象。这样可以将推导式的执行速度提高最多2倍。

推导式迭代变量保持隔离；它们不会覆盖外部作用域中的同名变量，在推导式后也不可见。这种隔离现在是通过堆栈/本地变量操作来维护的，而不是通过单独的函数作用域。

内联确实会导致一些明显的行为变化：

  * 回溯中的推导式不再有单独的帧，跟踪/评测也不再将推导式显示为函数调用。

  * [`symtable`](../library/symtable.md#module-symtable "symtable: Interface to the compiler's internal symbol tables.") 模块将不再为每个推导式产生子符号表；取而代之的是，推导式的 locals 将包括在父函数的符号表中。

  * 在推导式内部调用 [`locals()`](../library/functions.md#locals "locals") 现在包括该推导式外部外部的变量，而不再包括推导式“参数”导致的 `.0` 合成变量。

  * 一个直接迭代 `locals()` 的推导式 (例如 `[k for k in locals()]`) 在启动追踪 (例如检测代码覆盖度) 的情况下运行时可能导致 "RuntimeError: dictionary changed size during iteration"。 此行为与现有的 `for k in locals():` 等代码保持一致。 要避免此错误，可先创建一个由键组成的列表用于迭代: `keys = list(locals()); [k for k in keys]`。

由 Carl Meyer 和 Vladimir Matveev 在 [**PEP 709**](https://peps.python.org/pep-0709/) 中贡献。

### PEP 688: 使缓冲区协议在Python中可访问¶

[**PEP 688**](https://peps.python.org/pep-0688/) 引入了一种在 Python 代码中使用 [缓冲区协议](../c-api/buffer.md#bufferobjects) 的方法。实现 [`__buffer__()`](../reference/datamodel.md#object.__buffer__ "object.__buffer__") 方法的类现在可以作为缓冲区类型使用。

新的 [`collections.abc.Buffer`](../library/collections.abc.md#collections.abc.Buffer "collections.abc.Buffer") ABC（抽象基类）提供了一种表示缓冲区对象的标准方法，例如在类型注释中。 新的 [`inspect.BufferFlags`](../library/inspect.md#inspect.BufferFlags "inspect.BufferFlags") 枚举表示可用于自定义缓冲区创建的标志。 （由 Jelle Zijlstra 在 [gh-102500](https://github.com/python/cpython/issues/102500) 中贡献。）

### PEP 684: 解释器级 GIL¶

现在可以创建具有单独解释器级 GIL 的子解释器。 这将允许 Python 程序就能充分利用多个 CPU 内核。

使用新的 [`Py_NewInterpreterFromConfig()`](../c-api/init.md#c.Py_NewInterpreterFromConfig "Py_NewInterpreterFromConfig") 函数来创建具有单独 GIL 的解释器:

    
    
~~~
PyInterpreterConfig config = {
    .check_multi_interp_extensions = 1,
    .gil = PyInterpreterConfig_OWN_GIL,
};
PyThreadState *tstate = NULL;
PyStatus status = Py_NewInterpreterFromConfig(&tstate, &config);
if (PyStatus_Exception(status)) {
    return -1;
}
/* The new interpeter is now active in the current thread. */
~~~

有关如何将 C-API 用于子解释器和解释器级 GIL 的更多示例，请参见 [Modules/_xxsubinterpretersmodule.c](https://github.com/python/cpython/tree/3.12/Modules/_xxsubinterpretersmodule.c)。

预计 3.13 版将提供相应的 Python API。 （参见 [**PEP 554**](https://peps.python.org/pep-0554/)。）

（由 Eric Snow 在 [gh-104210](https://github.com/python/cpython/issues/104210) 等中贡献。）

### PEP 669：针对 CPython 的低影响监控¶

CPython 3.12 现在支持使用工具来监控调用、返回、行、异常和其他事件等。 这意味着你只为你所使用的东西耗费资源，从而为近乎零开销的调试器和覆盖检查工具提供了支持。

请参阅 [`sys.monitoring`](../library/sys.monitoring.md#module-sys.monitoring "sys.monitoring: Access and control event monitoring") 来了解详情。

## 有关类型提示的新增特性¶

本节介绍了涉及 [**PEP 484**](https://peps.python.org/pep-0484/) 类型提示和 [`typing`](../library/typing.md#module-typing "typing: Support for type hints \(see :pep:`484`\).") 模块的主要更改。

### PEP 692: 使用 `TypedDict` 进行更精确的 `**kwargs` 类型标注¶

在函数签名中的 `**kwargs` 类型标注（由 [**PEP 484**](https://peps.python.org/pep-0484/) 引入）只允许在所有 `**kwargs` 都属于同一类型的情况下进行有效标注。

此 PEP 指定了一种更精确的 `**kwargs` 类型标注的方法，该方法依赖于类型化的词典

    
    
~~~
from typing import TypedDict, Unpack

class Movie(TypedDict):
  name: str
  year: int

def foo(**kwargs: Unpack[Movie]): ...
~~~

更多细节请参见 [**PEP 692**](https://peps.python.org/pep-0692/)。

（由 Franek Magiera 在 [gh-103629](https://github.com/python/cpython/issues/103629) 中贡献。）

### PEP 698：覆盖静态类型的装饰器¶

一个新的装饰器 [`typing.override()`](../library/typing.md#typing.override "typing.override") 已添加到 [`typing`](../library/typing.md#module-typing "typing: Support for type hints \(see :pep:`484`\).") 模块中。 它向类型检查器指示该方法旨在重写超类中的方法。 这允许类型检查器在打算重写基类中的某个方法实际上没有重写的情况下捕获错误。

示例：

    
    
~~~
from typing import override

class Base:
  def get_color(self) -> str:
    return "blue"

class GoodChild(Base):
  @override  # ok: overrides Base.get_color
  def get_color(self) -> str:
    return "yellow"

class BadChild(Base):
  @override  # type checker error: does not override Base.get_color
  def get_colour(self) -> str:
    return "red"
~~~

（由 Steven Troxler 在 [gh-101561](https://github.com/python/cpython/issues/101561) 中贡献。）

### PEP 695: 类型形参语法¶

[**PEP 484**](https://peps.python.org/pep-0484/) 下的泛型类和函数是使用详细语法声明的，这使得类型参数的范围不明确，并且需要显式声明方差。

[**PEP 695**](https://peps.python.org/pep-0695/) 引入了一种新的、更紧凑、更明确的方式来创建 [泛型类](../reference/compound_stmts.md#generic-classes) 和 [函数](../reference/compound_stmts.md#generic-functions):

    
    
~~~python
def max[T](args: Iterable[T]) -> T:
    ...

class list[T]:
    def __getitem__(self, index: int, /) -> T:
        ...

    def append(self, element: T) -> None:
        ...
~~~

此外，该 PEP 引入了一种新的方法来使用 [`type`](../reference/simple_stmts.md#type) 语句声明 [类型别名](../library/typing.md#type-aliases)，该语句会创建 [`TypeAliasType`](../library/typing.md#typing.TypeAliasType "typing.TypeAliasType") 的实例:

    
    
~~~
type Point = tuple[float, float]
~~~

类型别名也可以是 [generic](../reference/compound_stmts.md#generic-type-aliases):

    
    
~~~
type Point[T] = tuple[T, T]
~~~

新语法允许声明 [`TypeVarTuple`](../library/typing.md#typing.TypeVarTuple "typing.TypeVarTuple") 和 [`ParamSpec`](../library/typing.md#typing.ParamSpec "typing.ParamSpec") 形参，以及带边界或约束的 [`TypeVar`](../library/typing.md#typing.TypeVar "typing.TypeVar") 形参:

    
    
~~~
type IntFunc[**P] = Callable[P, int]  # ParamSpec
type LabeledTuple[*Ts] = tuple[str, *Ts]  # TypeVarTuple
type HashableSequence[T: Hashable] = Sequence[T]  # TypeVar with bound
type IntOrStrSequence[T: (int, str)] = Sequence[T]  # TypeVar with constraints
~~~

类型别名的值以及通过此语法创建的类型变量的边界和约束仅根据需要进行计算 (参见 [惰性求值](../reference/executionmodel.md#lazy-evaluation))。 这意味着类型别名可以引用稍后在文件中定义的其它类型。

通过类型参数列表声明的类型参数在声明的作用域和任何嵌套的作用域内都可见，但在外部作用域内不可见。 例如，它们可以用于泛型类的方法的类型注解或类体中。 但是，在定义类之后，不能在模块范围中使用它们。 有关类型参数的运行时语义的详细描述，请参见 [类型形参列表](../reference/compound_stmts.md#type-params)。

为了支持这些作用域定义，引入了一种新的作用域，即 [标注作用域](../reference/executionmodel.md#annotation-scopes)。 标注作用域的行为在很大程度上类似于函数作用域，但与封闭类作用作用域的交互方式不同。 在 Python 3.13 中，[标注](../glossary.md#term-annotation) 也将在标注作用域中进行求值。

更多细节请参见 [**PEP 695**](https://peps.python.org/pep-0695/)。

（PEP由 Eric Traut 撰写。 由 Jelle Zijlstra、Eric Traut 和其他人在 [gh-103764](https://github.com/python/cpython/issues/103764) 中实现。）

## 其他语言特性修改¶

  * 通过新的环境变量 [`PYTHONPERFSUPPORT`](../using/cmdline.md#envvar-PYTHONPERFSUPPORT)、新的命令行选项 [`-X perf`](../using/cmdline.md#cmdoption-X) 以及新的 [`sys.activate_stack_trampoline()`](../library/sys.md#sys.activate_stack_trampoline "sys.activate_stack_trampoline")、[`sys.deactivate_stack_trampoline()`](../library/sys.md#sys.deactivate_stack_trampoline "sys.deactivate_stack_trampoline") 和 [`sys.is_stack_trampoline_active()`](../library/sys.md#sys.is_stack_trampoline_active "sys.is_stack_trampoline_active") API 来添加 [Python 对 Linux perf 性能分析器的支持](../howto/perf_profiling.md#perf-profiling)。 （由 Pablo Galindo 设计。 由 Pablo Gallindo 和 Christian Heimes 并包含来自 Gregory P. Smith [Google] 和 Mark Shannon 在 [gh-96123](https://github.com/python/cpython/issues/96123) 中的贡献。）

  * [`tarfile`](../library/tarfile.md#module-tarfile "tarfile: Read and write tar-format archive files.") 和 [`shutil.unpack_archive()`](../library/shutil.md#shutil.unpack_archive "shutil.unpack_archive") 中的提取方法有一个新的 _filter_ 参数，该参数允许限制可能令人惊讶或危险的 tar 功能，例如在目标目录之外创建文件。 有关详细信息，请参阅 [解压缩过滤器](../library/tarfile.md#tarfile-extraction-filter) 提取筛选器。 在 Python 3.14 中，默认值将切换为 `'data'`。 （由 Petr Viktorin 在 [**PEP 706**](https://peps.python.org/pep-0706/) 中贡献。）

  * 如果底层映射是可哈希的，那么 [`types.MappingProxyType`](../library/types.md#types.MappingProxyType "types.MappingProxyType") 实例现在是可哈希的。 （由 Serhiy Storchaka 在 [gh-87995](https://github.com/python/cpython/issues/87995) 中贡献。）

  * [`memoryview`](../library/stdtypes.md#memoryview "memoryview") 现在支持半浮点类型（“e”格式代码）。 （由 Dong-hee Na 和 Antoine Pitrou 在 [gh-90751](https://github.com/python/cpython/issues/90751) 中贡献。）

  * 解析器现在在解析包含空字节的源代码时引发 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError")。 （由 Pablo Galindo 在 [gh-96670](https://github.com/python/cpython/issues/96670) 中贡献 。）

  * [`ast.parse()`](../library/ast.md#ast.parse "ast.parse") 现在会在解析包含空字节的源代码时引发 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError") 而不是 [`ValueError`](../library/exceptions.md#ValueError "ValueError")。 （由 Pablo Galindo 在 [gh-96670](https://github.com/python/cpython/issues/96670) 中贡献 。）

  * 垃圾回收器现在只在 Python 字节码评估循环的 eval-breaker 机制上运行，而不是在对象分配上运行。 垃圾回收也可以在调用 [`PyErr_CheckSignals()`](../c-api/exceptions.md#c.PyErr_CheckSignals "PyErr_CheckSignals") 时运行，因此需要长时间运行而不执行任何 Python 代码的 C 扩展也有机会定期执行垃圾回收。 （由 Pablo Galindo 在 [gh-97922](https://github.com/python/cpython/issues/97922) 中贡献。）

  * 不是有效转义序列的反斜杠+字符的组合现在会生成 [`SyntaxWarning`](../library/exceptions.md#SyntaxWarning "SyntaxWarning")，而不是 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 例如，`re.compile("\d+\.\d+")` 现在会发出 [`SyntaxWarning`](../library/exceptions.md#SyntaxWarning "SyntaxWarning") (`"\d"` 是一个无效的转义序列)，对正则表达式使用原始字符串: `re.compile(r"\d+\.\d+")`。 在未来的 Python 版本中，最终将引发 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError")，而不是 [`SyntaxWarning`](../library/exceptions.md#SyntaxWarning "SyntaxWarning")。 （由 Victor Stinner 在 [gh-98401](https://github.com/python/cpython/issues/98401) 中贡献。）

  * 值大于 `0o377` (例如: `"\477"`) 的八进制转义序列，在 Python 3.11 中已弃用，现在会产生 [`SyntaxWarning`](../library/exceptions.md#SyntaxWarning "SyntaxWarning")，而不是 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 在未来的 Python 版本中，它们最终将是 [`SyntaxError`](../library/exceptions.md#SyntaxError "SyntaxError")。 （由 Victor Stinner 在 [gh-98401](https://github.com/python/cpython/issues/98401) 中贡献。）

  * 所有期望布尔参数的内置和扩展可调用函数现在都接受任何类型的参数，而不仅仅是 [`bool`](../library/functions.md#bool "bool") 和 [`int`](../library/functions.md#int "int")。 （由 Serhiy Storchaka 在 [gh-60203](https://github.com/python/cpython/issues/60203) 中贡献。）

  * 未存储在推导式目标部分中的变量现在可以在赋值表达式 (`:=`) 中使用。 例如，在 `[(b := 1) for a, b.prop in some_iter]` 中，现在允许对 `b` 进行赋值。 请注意，根据 [**PEP 572**](https://peps.python.org/pep-0572/)，仍然不允许向存储在推导式目标部分中的变量 (如 `a`) 赋值。 （由 Nikita Sobolev 在 [gh-100581](https://github.com/python/cpython/issues/100581) 中贡献。）

  * [`slice`](../library/functions.md#slice "slice") 对象现在是可哈希的，允许它们用作字典的键和集合项。 （由 Will Bradshaw、Furkan Onder 和 Raymond Hettinger 在 [gh-101264](https://github.com/python/cpython/issues/101264) 中贡献。）

  * [`sum()`](../library/functions.md#sum "sum") now uses Neumaier summation to improve accuracy and commutativity when summing floats or mixed ints and floats. (Contributed by Raymond Hettinger in [gh-100425](https://github.com/python/cpython/issues/100425).)

  * 类型对象的 `__set_name__` 方法引发的异常不再由 [`RuntimeError`](../library/exceptions.md#RuntimeError "RuntimeError") 封装。 上下文信息将作为 [**PEP 678**](https://peps.python.org/pep-0678/) 注释添加到异常中。 （由 Irit Katriel 在 [gh-77757](https://github.com/python/cpython/issues/77757) 中贡献。）

  * 当 `try-except*` 构造处理整个 [`ExceptionGroup`](../library/exceptions.md#ExceptionGroup "ExceptionGroup") 并引发另一个异常时，该异常不再封装在 [`ExceptionGroup`](../library/exceptions.md#ExceptionGroup "ExceptionGroup") 中。 在 3.11.4 版中也进行了更改。 （由 Irit Katriel 在 [gh-103590](https://github.com/python/cpython/issues/103590) 中贡献。）

## 新增模块¶

  * 无。

## 改进的模块¶

### array¶

  * [`array.array`](../library/array.md#array.array "array.array") 类现在支持下标，使其成为 [generic type](../glossary.md#term-generic-type)。 （由 Jelle Zijlstra 在 [gh-98658](https://github.com/python/cpython/issues/98658) 中贡献。）

### asyncio¶

  * 在 [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O.") 中写入套接字的性能得到了显著提高。 `asyncio` 现在可以避免在写入套接字时进行不必要的复制，并在平台支持的情况下使用 [`sendmsg()`](../library/socket.md#socket.socket.sendmsg "socket.socket.sendmsg")。 （由 Kumar Aditya 在 [gh-91166](https://github.com/python/cpython/issues/91166) 中贡献。）

  * 添加了 [`asyncio.eager_task_factory()`](../library/asyncio-task.md#asyncio.eager_task_factory "asyncio.eager_task_factory") 和 [`asyncio.create_eager_task_factory()`](../library/asyncio-task.md#asyncio.create_eager_task_factory "asyncio.create_eager_task_factory") 函数，允许在紧急任务执行中选择事件循环，使某些用例的速度提高了 2 到 5 倍。 （由 Jacob Bower 和 Itamar O 在 [gh-102853](https://github.com/python/cpython/issues/102853)、[gh-104140](https://github.com/python/cpython/issues/104140) 和 [gh-104138](https://github.com/python/cpython/issues/104138) 中贡献。）

  * 在 Linux 上，如果 [`os.pidfd_open()`](../library/os.md#os.pidfd_open "os.pidfd_open") 可用且能工作，[`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O.") 默认使用 [`PidfdChildWatcher`](../library/asyncio-policy.md#asyncio.PidfdChildWatcher "asyncio.PidfdChildWatcher") 而不是 [`ThreadedChildWatcher`](../library/asyncio-policy.md#asyncio.ThreadedChildWatcher "asyncio.ThreadedChildWatcher")。 （由 Kumar Aditya 在 [gh-98024](https://github.com/python/cpython/issues/98024) 中贡献。）

  * 子观察程序类 [`MultiLoopChildWatcher`](../library/asyncio-policy.md#asyncio.MultiLoopChildWatcher "asyncio.MultiLoopChildWatcher")、[`FastChildWatcher`](../library/asyncio-policy.md#asyncio.FastChildWatcher "asyncio.FastChildWatcher")、[`AbstractChildWatcher`](../library/asyncio-policy.md#asyncio.AbstractChildWatcher "asyncio.AbstractChildWatcher") 和 [`SafeChildWatcher`](../library/asyncio-policy.md#asyncio.SafeChildWatcher "asyncio.SafeChildWatcher") 已弃用，它们将在 Python 3.14 中移除。 建议不要手动配置子观察程序，因为事件循环现在为每个平台使用最佳可用的子观察程序 (如果支持就用 [`PidfdChildWatcher`](../library/asyncio-policy.md#asyncio.PidfdChildWatcher "asyncio.PidfdChildWatcher")，不支持则用 [`ThreadedChildWatcher`](../library/asyncio-policy.md#asyncio.ThreadedChildWatcher "asyncio.ThreadedChildWatcher"))。 （由 Kumar Aditya 在 [gh-94597](https://github.com/python/cpython/issues/94597) 中贡献。）

  * [`asyncio.set_child_watcher()`](../library/asyncio-policy.md#asyncio.set_child_watcher "asyncio.set_child_watcher")、[`asyncio.get_child_watcher()`](../library/asyncio-policy.md#asyncio.get_child_watcher "asyncio.get_child_watcher")、[`asyncio.AbstractEventLoopPolicy.set_child_watcher()`](../library/asyncio-policy.md#asyncio.AbstractEventLoopPolicy.set_child_watcher "asyncio.AbstractEventLoopPolicy.set_child_watcher") 和 [`asyncio.AbstractEventLoopPolicy.get_child_watcher()`](../library/asyncio-policy.md#asyncio.AbstractEventLoopPolicy.get_child_watcher "asyncio.AbstractEventLoopPolicy.get_child_watcher") 已弃用，并将在 Python 3.14 中移除。（由 Kumar Aditya 在 [gh-94597](https://github.com/python/cpython/issues/94597) 中贡献。）

  * 为 [`asyncio.run()`](../library/asyncio-runner.md#asyncio.run "asyncio.run") 添加了形参 _loop_factory_ ，以允许指定自定义事件循环工厂。 （由 Kumar Aditya 在 [gh-99388](https://github.com/python/cpython/issues/99388) 中贡献。）

  * 添加了 [`asyncio.current_task()`](../library/asyncio-task.md#asyncio.current_task "asyncio.current_task") 的 C 实现，以实现 4 - 6 倍的加速。 （由 Itamar Ostricher 和 Pranav Thulasiram Bhat 在 [gh-100344](https://github.com/python/cpython/issues/100344) 中贡献。）

  * [`asyncio.iscoroutine()`](../library/asyncio-task.md#asyncio.iscoroutine "asyncio.iscoroutine") 现在为生成器返回 `False`，因为 [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O.") 不支持传统的基于生成器的协程。 （由 Kumar Aditya 在 [gh-102748](https://github.com/python/cpython/issues/102748) 中贡献。）

  * [`asyncio.wait()`](../library/asyncio-task.md#asyncio.wait "asyncio.wait") 和 [`asyncio.as_completed()`](../library/asyncio-task.md#asyncio.as_completed "asyncio.as_completed") 现在接受生成器 yield 任务。 （由 Kumar Aditya 在 [gh-78530](https://github.com/python/cpython/issues/78530) 中贡献。）

### calendar¶

  * 添加 [`Month`](../library/calendar.md#calendar.Month "calendar.Month") 和 [`Day`](../library/calendar.md#calendar.Day "calendar.Day") 枚举。 （由 Prince Roshan 在 [gh-103636](https://github.com/python/cpython/issues/103636) 中贡献。）

### csv¶

  * 增加了 [`QUOTE_NOTNULL`](../library/csv.md#csv.QUOTE_NOTNULL "csv.QUOTE_NOTNULL") 和 [`QUOTE_STRINGS`](../library/csv.md#csv.QUOTE_STRINGS "csv.QUOTE_STRINGS") 旗标以通过 [`writer`](../library/csv.md#csv.writer "csv.writer") 对象提供对 `None` 和空字符串的更细粒度控制。

### dis¶

  * 伪指令操作码（编译器使用，但不出现在可执行字节码中）现在暴露在 [`dis`](../library/dis.md#module-dis "dis: Disassembler for Python bytecode.") 模块中。 [`HAVE_ARGUMENT`](../library/dis.md#opcode-HAVE_ARGUMENT) 仍然与实际操作码相关，但对伪指令没有用处。请改用新的 [`hasarg`](../library/dis.md#dis.hasarg "dis.hasarg") 多项集。 （由 Irit Katriel 在 [gh-94216](https://github.com/python/cpython/issues/94216) 中贡献。）

### fractions¶

  * 类型为 [`fractions.Fraction`](../library/fractions.md#fractions.Fraction "fractions.Fraction") 的对象现在支持浮点格式。 （由 Mark Dickinson 在 [gh-100161](https://github.com/python/cpython/issues/100161) 中贡献。）

### importlib.resources¶

  * [`importlib.resources.as_file()`](../library/importlib.resources.md#importlib.resources.as_file "importlib.resources.as_file") 现在将支持资源目录。 （由 Jason R. Coombs 在 [gh-97930](https://github.com/python/cpython/issues/97930) 中贡献。）

### inspect¶

  * 添加 [`inspect.markcoroutinefunction()`](../library/inspect.md#inspect.markcoroutinefunction "inspect.markcoroutinefunction") 来标记返回 [coroutine](../glossary.md#term-coroutine) 的同步函数，以便与 [`inspect.iscoroutinefunction()`](../library/inspect.md#inspect.iscoroutinefunction "inspect.iscoroutinefunction") 一起使用。 （由 Carlton Gibson 在 [gh-99247](https://github.com/python/cpython/issues/99247) 中贡献。）

  * 添加 [`inspect.getasyncgenstate()`](../library/inspect.md#inspect.getasyncgenstate "inspect.getasyncgenstate") 和 [`inspect.getasyncgenlocals()`](../library/inspect.md#inspect.getasyncgenlocals "inspect.getasyncgenlocals") 来确定异步生成器的当前状态。 （由 Thomas Krennwallner 在 [bpo-35759](https://bugs.python.org/issue?@action=redirect&bpo=35759) 中贡献。）

  * [`inspect.getattr_static()`](../library/inspect.md#inspect.getattr_static "inspect.getattr_static") 的性能得到了相当大的改进。 对函数的大多数调用应该比 Python 3.11 中至少快 2 倍，有些可能快 6 倍甚至更多。 （由 Alex Waygood 在 [gh-103193](https://github.com/python/cpython/issues/103193) 中贡献。）

### itertools¶

  * 增加了 [`itertools.batched()`](../library/itertools.md#itertools.batched "itertools.batched") 用来收集到相同大小的元组其中最后一个批次的长度可能会比其他批次的短。 （由 Raymond Hettinger 在 [gh-98363](https://github.com/python/cpython/issues/98363) 中贡献。）

### math¶

  * 添加了 [`math.sumprod()`](../library/math.md#math.sumprod "math.sumprod") 用于计算乘积的和。 （由 Raymond Hettinger 在 [gh-100485](https://github.com/python/cpython/issues/100485) 中贡献。）

  * 扩展了 [`math.nextafter()`](../library/math.md#math.nextafter "math.nextafter") 以包含一个 _steps_ 参数，用于一次上移或下移多个步骤。 （由 Matthias Goergens、Mark Dickinson 和 Raymond Hettinger在 [gh-94906](https://github.com/python/cpython/issues/94906) 中贡献。）

### os¶

  * 增加了 [`os.PIDFD_NONBLOCK`](../library/os.md#os.PIDFD_NONBLOCK "os.PIDFD_NONBLOCK") 以在非阻塞模式下打开具有 [`os.pidfd_open()`](../library/os.md#os.pidfd_open "os.pidfd_open") 的进程的文件描述符。 （由 Kumar Aditya 在 [gh-93312](https://github.com/python/cpython/issues/93312) 中贡献。）

  * [`os.DirEntry`](../library/os.md#os.DirEntry "os.DirEntry") 现在包括一个 [`os.DirEntry.is_junction()`](../library/os.md#os.DirEntry.is_junction "os.DirEntry.is_junction") 方法来检查该条目是否为目录联接。 （由 Charles Machalow 在 [gh-99547](https://github.com/python/cpython/issues/99547) 中贡献。）

  * 在 Windows 版中添加 [`os.listdrives()`](../library/os.md#os.listdrives "os.listdrives")、[`os.listvolumes()`](../library/os.md#os.listvolumes "os.listvolumes") 和 [`os.listmounts()`](../library/os.md#os.listmounts "os.listmounts") 函数，用于枚举驱动器、卷和挂载点。 （由 Steve Dower 在 [gh-102519](https://github.com/python/cpython/issues/102519) 中贡献。）

  * [`os.stat()`](../library/os.md#os.stat "os.stat") 和 [`os.lstat()`](../library/os.md#os.lstat "os.lstat") 现在在 Windows 系统上更准确了。 `st_birthtime` 字段现在将使用文件的创建时间，`st_ctime` 已弃用，但仍包含创建时间（但为了与其他平台保持一致，将来将返回最后一次元数据更改时间）。 `st_dev` 可以高达 64 位，`st_ino` 可以高达 128 位，具体取决于你的文件系统，并且 `st_rdev` 始终设置为零，而非不正确的值。 这两个函数在较新版本的 Windows 上将会明显更快。 （由 Steve Dower 在 [gh-99726](https://github.com/python/cpython/issues/99726) 中贡献。）

### os.path¶

  * 添加 [`os.path.isjunction()`](../library/os.path.md#os.path.isjunction "os.path.isjunction") 以检查给定路径是否为目录联接。 （由 Charles Machalow 在 [gh-99547](https://github.com/python/cpython/issues/99547) 中贡献。）

  * 添加 [`os.path.splitroot()`](../library/os.path.md#os.path.splitroot "os.path.splitroot") 以将路径拆分为三元组 `(drive, root, tail)`。（由 Barney Gale 在 [gh-101000](https://github.com/python/cpython/issues/101000) 中贡献。）

### pathlib¶

  * 增加对 [`pathlib.PurePath`](../library/pathlib.md#pathlib.PurePath "pathlib.PurePath") 和 [`Path`](../library/pathlib.md#pathlib.Path "pathlib.Path") 的子类化支持，以及它们的 Posix 和 Windows 特定变体。 子类可以重写 [`with_segments()`](../library/pathlib.md#pathlib.PurePath.with_segments "pathlib.PurePath.with_segments") 方法来在路径实例之间传递信息。

  * 添加 [`walk()`](../library/pathlib.md#pathlib.Path.walk "pathlib.Path.walk")，用于遍历目录树并生成其中的所有文件或目录名，类似于 [`os.walk()`](../library/os.md#os.walk "os.walk")。 （由 Stanislav Zmiev 在 [gh-90385](https://github.com/python/cpython/issues/90385) 中贡献。）

  * 添加可选形参 _walk_up_ 到 [`pathlib.PurePath.relative_to()`](../library/pathlib.md#pathlib.PurePath.relative_to "pathlib.PurePath.relative_to")，以允许在结果中插入 `..` 条目；此行为更符合 [`os.path.relpath()`](../library/os.path.md#os.path.relpath "os.path.relpath")。 （由 Domenico Ragusa 在 [bpo-40358](https://bugs.python.org/issue?@action=redirect&bpo=40358) 中贡献。）

  * 添加 [`pathlib.Path.is_junction()`](../library/pathlib.md#pathlib.Path.is_junction "pathlib.Path.is_junction") 作为 [`os.path.isjunction()`](../library/os.path.md#os.path.isjunction "os.path.isjunction") 的代理。 （由 Charles Machalow 在 [gh-99547](https://github.com/python/cpython/issues/99547) 中贡献。）

  * 为 [`pathlib.Path.glob()`](../library/pathlib.md#pathlib.Path.glob "pathlib.Path.glob")、[`pathlib.Path.rglob()`](../library/pathlib.md#pathlib.Path.rglob "pathlib.Path.rglob") 和 [`pathlib.PurePath.match()`](../library/pathlib.md#pathlib.PurePath.match "pathlib.PurePath.match") 添加可选形参 _case_sensitive_ ，以匹配路径的大小写敏感性，从而对匹配过程进行更精确的控制。

### pdb¶

  * 添加便利变量以临时保存调试会话的值，并提供对当前帧或返回值等值的快速访问。 （由高天在 [gh-103693](https://github.com/python/cpython/issues/103693) 中贡献。）

### random¶

  * 添加了 [`random.binomialvariate()`](../library/random.md#random.binomialvariate "random.binomialvariate")。 （由 Raymond Hettinger 在 [gh-81620](https://github.com/python/cpython/issues/81620) 中贡献。）

  * 在 [`random.expovariate()`](../library/random.md#random.expovariate "random.expovariate") 中添加了一个默认值 `lamb=1.0`。 （由 Raymond Hettinger 在 [gh-100234](https://github.com/python/cpython/issues/100234) 中贡献。）

### shutil¶

  * [`shutil.make_archive()`](../library/shutil.md#shutil.make_archive "shutil.make_archive") 现在将 _rootdir_ 参数传递给支持它的自定义存档程序。 在这种情况下，它不再临时将进程的当前工作目录更改为 _rootdir_ 来执行存档。 （由 Serhiy Storchaka 在 [gh-74696](https://github.com/python/cpython/issues/74696) 中贡献。）

  * [`shutil.rmtree()`](../library/shutil.md#shutil.rmtree "shutil.rmtree") 现在接受一个新的参数 _onexc_ ，它是一个类似 _onerror_ 的错误处理器，但它需要一个异常实例，而不是一个 _(typ, val, tb)_ 三元组。 _onerror_ 已弃用，并将在 Python 3.14 中移除。 （由 Irit Katriel 在 [gh-102828](https://github.com/python/cpython/issues/102828) 中贡献。）

  * [`shutil.which()`](../library/shutil.md#shutil.which "shutil.which") 现在即使给定的 _cmd_ 包含目录组件，在 Windows 系统上也会参考 _PATHEXT_ 环境变量在 _PATH_ 中查找匹配项。 （由 Charles Machalow 在 [gh-103179](https://github.com/python/cpython/issues/103179) 中贡献。）

[`shutil.which()`](../library/shutil.md#shutil.which "shutil.which") 将在 Windows 上查询可执行文件时调用 `NeedCurrentDirectoryForExePathW`，以确定是否应将当前工作目录预先设置为搜索路径。 （由 Charles Machalow 在 [gh-103179](https://github.com/python/cpython/issues/103179) 中贡献。）

在 Windows 上 [`shutil.which()`](../library/shutil.md#shutil.which "shutil.which") 将在搜索路径的其他地方直接匹配之前返回 _cmd_ 与来自 `PATHEXT` 的组件相匹配的路径。 （由 Charles Machalow 在 [gh-103179](https://github.com/python/cpython/issues/103179) 中贡献。）

### sqlite3¶

  * 增加了一个 [命令行接口](../library/sqlite3.md#sqlite3-cli)。 （由 Erlend E. Aasland 在 [gh-77617](https://github.com/python/cpython/issues/77617) 中贡献。）

  * 向 [`Connection`](../library/sqlite3.md#sqlite3.Connection "sqlite3.Connection") 添加 [`autocommit`](../library/sqlite3.md#sqlite3.Connection.autocommit "sqlite3.Connection.autocommit") 属性并向 [`connect()`](../library/sqlite3.md#sqlite3.connect "sqlite3.connect") 添加 _autocommit_ 形参用于控制兼容 [**PEP 249**](https://peps.python.org/pep-0249/) 的 [事务处理](../library/sqlite3.md#sqlite3-transaction-control-autocommit)。 （由 Erlend E. Aasland 在 [gh-83638](https://github.com/python/cpython/issues/83638) 中贡献。）

  * 向 [`load_extension()`](../library/sqlite3.md#sqlite3.Connection.load_extension "sqlite3.Connection.load_extension") 添加了 _entrypoint_ 仅限关键字形参，用于覆盖 SQLite 扩展入口点。 （由 Erlend E. Aasland 在 [gh-103015](https://github.com/python/cpython/issues/103015) 中贡献。）

  * 向 [`Connection`](../library/sqlite3.md#sqlite3.Connection "sqlite3.Connection") 添加了 [`getconfig()`](../library/sqlite3.md#sqlite3.Connection.getconfig "sqlite3.Connection.getconfig") 和 [`setconfig()`](../library/sqlite3.md#sqlite3.Connection.setconfig "sqlite3.Connection.setconfig") 用于对数据库连接的配置修改。 （由 Erlend E. Aasland 在 [gh-103489](https://github.com/python/cpython/issues/103489) 中贡献。）

### statistics¶

  * 扩展了 [`statistics.correlation()`](../library/statistics.md#statistics.correlation "statistics.correlation") 以 `ranked` 方法的形式来包括对分级数据的斯皮尔曼相关性计算。 （由 Raymond Hettinger 在 [gh-95861](https://github.com/python/cpython/issues/95861) 中贡献。）

### sys¶

  * 增加了 [`sys.activate_stack_trampoline()`](../library/sys.md#sys.activate_stack_trampoline "sys.activate_stack_trampoline") 和 [`sys.deactivate_stack_trampoline()`](../library/sys.md#sys.deactivate_stack_trampoline "sys.deactivate_stack_trampoline") 用于激活和停用栈性能分析器 trampoline，以及 [`sys.is_stack_trampoline_active()`](../library/sys.md#sys.is_stack_trampoline_active "sys.is_stack_trampoline_active") 用于查询栈性能分析器 trampoline 是否激活。 （基于 Gregory P. Smith [Google] 和 Mark Shannon 的贡献由 Pablo Galindo 和 Christian Heimes 在 [gh-96123](https://github.com/python/cpython/issues/96123) 中贡献。）

  * 增加了 [`sys.last_exc`](../library/sys.md#sys.last_exc "sys.last_exc") 用于保存最新引发的未处理异常（针对事后调试的应用场景）。 弃用了以三个字段来保存相同信息的旧形式: [`sys.last_type`](../library/sys.md#sys.last_type "sys.last_type"), [`sys.last_value`](../library/sys.md#sys.last_value "sys.last_value") 和 [`sys.last_traceback`](../library/sys.md#sys.last_traceback "sys.last_traceback")。 （由 Irit Katriel 在 [gh-102778](https://github.com/python/cpython/issues/102778) 中贡献。）

  * 现在 [`sys._current_exceptions()`](../library/sys.md#sys._current_exceptions "sys._current_exceptions") 将返回从线程 ID 到异常实例的映射，而不是到 `(typ, exc, tb)` 元组的映射。 （由 Irit Katriel 在 [gh-103176](https://github.com/python/cpython/issues/103176) 中贡献。）

  * [`sys.setrecursionlimit()`](../library/sys.md#sys.setrecursionlimit "sys.setrecursionlimit") 和 [`sys.getrecursionlimit()`](../library/sys.md#sys.getrecursionlimit "sys.getrecursionlimit")。 递归限制现在只应用于 Python 代码。 内置函数不使用该递归限制，但受到另一种可防止递归导致虚拟机崩溃的机制保护。

### tempfile¶

  * [`tempfile.NamedTemporaryFile`](../library/tempfile.md#tempfile.NamedTemporaryFile "tempfile.NamedTemporaryFile") 函数增加了一个新的可选形参 _delete_on_close_ 。 （由 Evgeny Zorin 在 [gh-58451](https://github.com/python/cpython/issues/58451) 中贡献。）

  * [`tempfile.mkdtemp()`](../library/tempfile.md#tempfile.mkdtemp "tempfile.mkdtemp") 现在将总是返回一个绝对路径，即使提供给 _dir_ 形参的参数是一个相对路径。

### threading¶

  * 增加了 [`threading.settrace_all_threads()`](../library/threading.md#threading.settrace_all_threads "threading.settrace_all_threads") 和 [`threading.setprofile_all_threads()`](../library/threading.md#threading.setprofile_all_threads "threading.setprofile_all_threads") 以允许在所运行的全部线程中设置追踪和性能分析函数而不是只在调用方线程中。 （由 Pablo Galindo 在 [gh-93503](https://github.com/python/cpython/issues/93503) 中贡献。）

### tkinter¶

  * 现在 `tkinter.Canvas.coords()` 会展平其参数。 它现在不仅接受单独参数形式的坐标 (`x1, y1, x2, y2, ...`) 以及由坐标组成的序列 (`[x1, y1, x2, y2, ...]`)，也接受成对分组 (`(x1, y1), (x2, y2), ...` 和 `[(x1, y1), (x2, y2), ...]`) 形式的坐标，就像 `create_*()` 方法一样。 （由 Serhiy Storchaka 在 [gh-94473](https://github.com/python/cpython/issues/94473) 中贡献。）

### tokenize¶

  * [`tokenize`](../library/tokenize.md#module-tokenize "tokenize: Lexical scanner for Python source code.") 模块包括了 [**PEP 701**](https://peps.python.org/pep-0701/) 所引入的更改。 （由 Marta Gómez Macías 和 Pablo Galindo 在 [gh-102856](https://github.com/python/cpython/issues/102856) 中贡献。） 请参阅 移植到 Python 3.12 了解有关 [`tokenize`](../library/tokenize.md#module-tokenize "tokenize: Lexical scanner for Python source code.") 模块的更改详情。

### types¶

  * 增加了 [`types.get_original_bases()`](../library/types.md#types.get_original_bases "types.get_original_bases") 以允许在子类化时继续对 [用户定义的泛型类型](../library/typing.md#user-defined-generics) 进行内省。 （由 James Hilton-Balfe 和 Alex Waygood 在 [gh-101827](https://github.com/python/cpython/issues/101827) 中贡献。）

### typing¶

  * 针对 [`运行时可检测协议`](../library/typing.md#typing.runtime_checkable "typing.runtime_checkable") 的 [`isinstance()`](../library/functions.md#isinstance "isinstance") 检测现在会使用 [`inspect.getattr_static()`](../library/inspect.md#inspect.getattr_static "inspect.getattr_static") 而不是 [`hasattr()`](../library/functions.md#hasattr "hasattr") 来查找属性是否存在。 这意味着描述器和 [`__getattr__()`](../reference/datamodel.md#object.__getattr__ "object.__getattr__") 方法在针对运行时可检测协议的 `isinstance()` 检测期间不会被意外地求值。 但是，这也意味着某些原来被视为运行时可检测协议的实例的对象在 Python 3.12+ 上将不再被视为运行时可检测协议的实例，反之亦然。 大部分用户都不太可能受到这一改变的影响。 （由 Alex Waygood 在 [gh-102433](https://github.com/python/cpython/issues/102433) 中贡献。）

  * 现在运行时可检测协议的成员在运行时一旦创建了相应的类就将被视为“已冻结”。 作用于运行时可检测协议的猴子补丁属性将仍然可用，但不会再影响将对象与协议进行比较的 [`isinstance()`](../library/functions.md#isinstance "isinstance") 检测中。 例如:
    
        >>> from typing import Protocol, runtime_checkable
    >>> @runtime_checkable
    ... class HasX(Protocol):
    ...     x = 1
    ...
    >>> class Foo: ...
    ...
    >>> f = Foo()
    >>> isinstance(f, HasX)
    False
    >>> f.x = 1
    >>> isinstance(f, HasX)
    True
    >>> HasX.y = 2
    >>> isinstance(f, HasX)  # unchanged, even though HasX now also has a "y" attribute
    True
    

应用这项改变是为了提高针对运行时可检测协议的 `isinstance()` 检测速度。

  * 针对 [`运行时可检测协议`](../library/typing.md#typing.runtime_checkable "typing.runtime_checkable") 的 [`isinstance()`](../library/functions.md#isinstance "isinstance") 检测的性能表现有显著的改进。 对于具有少量成员的协议的 `isinstance()` 检测相比 3.11 应当至少有 2x 的提速，有些可能会有 20x 或更多的提速。 但是，对于具有十四个或更多成员的协议的 `isinstance()` 检测可能会慢于 Python 3.11。 （由 Alex Waygood 在 [gh-74690](https://github.com/python/cpython/issues/74690) 和 [gh-103193](https://github.com/python/cpython/issues/103193) 中贡献。）

  * 现在所有 [`typing.TypedDict`](../library/typing.md#typing.TypedDict "typing.TypedDict") 和 [`typing.NamedTuple`](../library/typing.md#typing.NamedTuple "typing.NamedTuple") 类都具有 `__orig_bases__` 属性。 （由 Adrian Garcia Badaracco 在 [gh-103699](https://github.com/python/cpython/issues/103699) 中贡献。）

  * 向 [`typing.dataclass_transform()`](../library/typing.md#typing.dataclass_transform "typing.dataclass_transform") 添加了 `frozen_default` 形参。 （由 Erik De Bonte 在 [gh-99957](https://github.com/python/cpython/issues/99957) 中贡献。）

### unicodedata¶

  * Unicode 数据库已更新到 15.0.0 版。 （由 Benjamin Peterson 在 [gh-96734](https://github.com/python/cpython/issues/96734) 中贡献。）

### unittest¶

增加了 `--durations` 命令行选项，显示 N 个最慢的测试用例:

    
    
~~~
python3 -m unittest --durations=3 lib.tests.test_threading
.....
Slowest test durations
----------------------------------------------------------------------
1.210s     test_timeout (Lib.test.test_threading.BarrierTests)
1.003s     test_default_timeout (Lib.test.test_threading.BarrierTests)
0.518s     test_timeout (Lib.test.test_threading.EventTests)

(0.000 durations hidden.  Use -v to show these durations.)
----------------------------------------------------------------------
Ran 158 tests in 9.869s

OK (skipped=3)
~~~

（由 Giampaolo Rodola 在 [bpo-4080](https://bugs.python.org/issue?@action=redirect&bpo=4080) 中贡献。）

### uuid¶

  * 增加了一个 [命令行接口](../library/uuid.md#uuid-cli)。 （由 Adam Chhina 在 [gh-88597](https://github.com/python/cpython/issues/88597) 中贡献。）

## 性能优化¶

  * 从 Unicode 对象中移除了 `wstr` 和 `wstr_length` 成员。 这使得对象大小在 64 位平台上减小了 8 个或 16 个字节。 ([ **PEP 623**](https://peps.python.org/pep-0623/)) （由 Inada Naoki 在 [gh-92536](https://github.com/python/cpython/issues/92536) 中贡献。）

  * 增加了在构建进程中使用 BOLT 二进制优化器的试验性支持，这将使使性能提升 1-5%。 （由 Kevin Modzelewski 在 [gh-90536](https://github.com/python/cpython/issues/90536) 中贡献并由 Dong-hee Na 在 [gh-101525](https://github.com/python/cpython/issues/101525) 中加以改进。）

  * 对于包含分组引用的替换字符串的正则表达式替换（包括 [`re.sub()`](../library/re.md#re.sub "re.sub") 和 [`re.subn()`](../library/re.md#re.subn "re.subn") 函数及对应的 `re.Pattern` 方法）可加速 2--3 倍。 （由 Serhiy Storchaka 在 [gh-91524](https://github.com/python/cpython/issues/91524) 中贡献。）

  * 通过推迟高消耗的字符串格式化来加速 [`asyncio.Task`](../library/asyncio-task.md#asyncio.Task "asyncio.Task") 的创建。 （由 Itamar O 在 [gh-103793](https://github.com/python/cpython/issues/103793) 中贡献。）

  * 作为在 [`tokenize`](../library/tokenize.md#module-tokenize "tokenize: Lexical scanner for Python source code.") 模块中应用 [**PEP 701**](https://peps.python.org/pep-0701/) 所要求的更改的附带效果，[`tokenize.tokenize()`](../library/tokenize.md#tokenize.tokenize "tokenize.tokenize") 和 [`tokenize.generate_tokens()`](../library/tokenize.md#tokenize.generate_tokens "tokenize.generate_tokens") 函数可加速至多 64%。 （由 Marta Gómez Macías 和 Pablo Galindo 在 [gh-102856](https://github.com/python/cpython/issues/102856) 中贡献。）

  * 通过新的 [`LOAD_SUPER_ATTR`](../library/dis.md#opcode-LOAD_SUPER_ATTR) 指令加速 [`super()`](../library/functions.md#super "super") 方法调用和属性加载。 （由 Carl Meyer 和 Vladimir Matveev 在 [gh-103497](https://github.com/python/cpython/issues/103497) 中贡献。）

## CPython 字节码的改变¶

  * 移除了 [`LOAD_METHOD`](../library/dis.md#opcode-LOAD_METHOD) 指令。 它已被合并至 [`LOAD_ATTR`](../library/dis.md#opcode-LOAD_ATTR)。 现在如果设置了 [`LOAD_ATTR`](../library/dis.md#opcode-LOAD_ATTR) 的 oparg 的低比特位则它的行为将类似原来的 [`LOAD_METHOD`](../library/dis.md#opcode-LOAD_METHOD)。 （由 Ken Jin 在 [gh-93429](https://github.com/python/cpython/issues/93429) 中贡献。）

  * 移除了 `JUMP_IF_FALSE_OR_POP` 和 `JUMP_IF_TRUE_OR_POP` 指令。 （由 Irit Katriel 在 [gh-102859](https://github.com/python/cpython/issues/102859) 中贡献。）

  * 移除了 `PRECALL` 指令。 （由 Mark Shannon 在 [gh-92925](https://github.com/python/cpython/issues/92925) 中贡献。）

  * 增加了 [`LOAD_FAST_AND_CLEAR`](../library/dis.md#opcode-LOAD_FAST_AND_CLEAR) 指令作为 [**PEP 709**](https://peps.python.org/pep-0709/) 的实现的组成部分。 （由 Carl Meyer 在 [gh-101441](https://github.com/python/cpython/issues/101441) 中贡献。）

  * 增加了 [`LOAD_FROM_DICT_OR_DEREF`](../library/dis.md#opcode-LOAD_FROM_DICT_OR_DEREF), [`LOAD_FROM_DICT_OR_GLOBALS`](../library/dis.md#opcode-LOAD_FROM_DICT_OR_GLOBALS) 和 [`LOAD_LOCALS`](../library/dis.md#opcode-LOAD_LOCALS) 操作码作为 [**PEP 695**](https://peps.python.org/pep-0695/) 的组成部分。 移除了 `LOAD_CLASSDEREF` 操作码，它可以用 [`LOAD_LOCALS`](../library/dis.md#opcode-LOAD_LOCALS) 加 [`LOAD_FROM_DICT_OR_DEREF`](../library/dis.md#opcode-LOAD_FROM_DICT_OR_DEREF) 来代替。 （由 Jelle Zijlstra 在 [gh-103764](https://github.com/python/cpython/issues/103764) 中贡献。）

  * 增加了 [`LOAD_SUPER_ATTR`](../library/dis.md#opcode-LOAD_SUPER_ATTR) 指令。 （由 Carl Meyer 和 Vladimir Matveev 在 [gh-103497](https://github.com/python/cpython/issues/103497) 中贡献。）

## 演示和工具¶

  * 移除了包含旧演示脚本的 `Tools/demo/` 目录。 其副本可在 [old-demos project](https://github.com/gvanrossum/old-demos) 中找到。 （由 Victor Stinner 在 [gh-97681](https://github.com/python/cpython/issues/97681) 中贡献。）

  * 移除了 `Tools/scripts/` 目录下过时的示例脚本。 其副本可在 [old-demos project](https://github.com/gvanrossum/old-demos) 中找到。 （由 Victor Stinner 在 [gh-97669](https://github.com/python/cpython/issues/97669) 中贡献。）

## 弃用¶

  * [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O."): 现在默认事件循环策略的 [`get_event_loop()`](../library/asyncio-eventloop.md#asyncio.get_event_loop "asyncio.get_event_loop") 方法在当前事件循环未设置并决定创建一个时将发出 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 （由 Serhiy Storchaka 和 Guido van Rossum 在 [gh-100160](https://github.com/python/cpython/issues/100160) 中贡献。）

  * [`calendar`](../library/calendar.md#module-calendar "calendar: Functions for working with calendars, including some emulation of the Unix cal program."): `calendar.January` 和 `calendar.February` 常量已被弃用并由 [`calendar.JANUARY`](../library/calendar.md#calendar.JANUARY "calendar.JANUARY") 和 [`calendar.FEBRUARY`](../library/calendar.md#calendar.FEBRUARY "calendar.FEBRUARY") 替代。 （由 Prince Roshan 在 [gh-103636](https://github.com/python/cpython/issues/103636) 中贡献。）

  * [`datetime`](../library/datetime.md#module-datetime "datetime: Basic date and time types."): [`datetime.datetime`](../library/datetime.md#datetime.datetime "datetime.datetime") 的 [`utcnow()`](../library/datetime.md#datetime.datetime.utcnow "datetime.datetime.utcnow") 和 [`utcfromtimestamp()`](../library/datetime.md#datetime.datetime.utcfromtimestamp "datetime.datetime.utcfromtimestamp") 已被弃用并将在未来的版本中移除。 请改用可感知时区的对象以 UTC 来表示日期时间：分别调用 [`now()`](../library/datetime.md#datetime.datetime.now "datetime.datetime.now") 和 [`fromtimestamp()`](../library/datetime.md#datetime.datetime.fromtimestamp "datetime.datetime.fromtimestamp") 并设置 _tz_ 形参为 [`datetime.UTC`](../library/datetime.md#datetime.UTC "datetime.UTC")。 （由 Paul Ganssle 在 [gh-103857](https://github.com/python/cpython/issues/103857) 中贡献。）

  * [`os`](../library/os.md#module-os "os: Miscellaneous operating system interfaces."): 在 Windows 上由 [`os.stat()`](../library/os.md#os.stat "os.stat") 和 [`os.lstat()`](../library/os.md#os.lstat "os.lstat") 返回的 `st_ctime` 字段已被弃用。 在未来的版本中，它们将包含最近的元数据修改时间，以与其他平台保持一致。 目前，它们仍然包含创建时间，该值也可通过新的 `st_birthtime` 字段获取。 （由 Steve Dower 在 [gh-99726](https://github.com/python/cpython/issues/99726) 中贡献。）

  * [`shutil`](../library/shutil.md#module-shutil "shutil: High-level file operations, including copying."): [`shutil.rmtree()`](../library/shutil.md#shutil.rmtree "shutil.rmtree") 的 _onerror_ 参数已被弃用并将在 Python 3.14 中移除。 请改用 _onexc_ 。 （由 Irit Katriel 在 [gh-102828](https://github.com/python/cpython/issues/102828) 中贡献。）

  * [`sqlite3`](../library/sqlite3.md#module-sqlite3 "sqlite3: A DB-API 2.0 implementation using SQLite 3.x."):
    
    * [默认适配器和转换器](../library/sqlite3.md#sqlite3-default-converters) 现在已被弃用，请使用 [适配器和转换器范例程序](../library/sqlite3.md#sqlite3-adapter-converter-recipes) 并根据你的需要调整它们。 （由 Erlend E. Aasland 在 [gh-90016](https://github.com/python/cpython/issues/90016) 中贡献。）

    * 在 [`execute()`](../library/sqlite3.md#sqlite3.Cursor.execute "sqlite3.Cursor.execute") 中，现在当 [命名占位符](../library/sqlite3.md#sqlite3-placeholders) 与作为 [sequence](../glossary.md#term-sequence) 而不是 [`dict`](../library/stdtypes.md#dict "dict") 提供的形参一起使用时将发出 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 从 Python 3.14 开始，当命名占位符与作为序列提供的形参一起使用时将引发 [`ProgrammingError`](../library/sqlite3.md#sqlite3.ProgrammingError "sqlite3.ProgrammingError")。 （由 Erlend E. Aasland 在 [gh-101698](https://github.com/python/cpython/issues/101698) 中贡献。）

  * [`sys`](../library/sys.md#module-sys "sys: Access system-specific parameters and functions."): [`sys.last_type`](../library/sys.md#sys.last_type "sys.last_type"), [`sys.last_value`](../library/sys.md#sys.last_value "sys.last_value") 和 [`sys.last_traceback`](../library/sys.md#sys.last_traceback "sys.last_traceback") 字段已被弃用。 请改用 [`sys.last_exc`](../library/sys.md#sys.last_exc "sys.last_exc")。 （由 Irit Katriel 在 [gh-102778](https://github.com/python/cpython/issues/102778) 中贡献。）

  * [`tarfile`](../library/tarfile.md#module-tarfile "tarfile: Read and write tar-format archive files."): 提取 tar 归档而不指定 _filter_ 的做法已被弃用直到 Python 3.14，在该版本中 `'data'` 将成为默认过滤器。 请参阅 [解压缩过滤器](../library/tarfile.md#tarfile-extraction-filter) 了解详情。

  * [`typing`](../library/typing.md#module-typing "typing: Support for type hints \(see :pep:`484`\)."): [`typing.Hashable`](../library/typing.md#typing.Hashable "typing.Hashable") 和 [`typing.Sized`](../library/typing.md#typing.Sized "typing.Sized") 是 [`collections.abc.Hashable`](../library/collections.abc.md#collections.abc.Hashable "collections.abc.Hashable") 和 [`collections.abc.Sized`](../library/collections.abc.md#collections.abc.Sized "collections.abc.Sized") 的别名。 （参见 [gh-94309](https://github.com/python/cpython/issues/94309)。）

  * [`xml.etree.ElementTree`](../library/xml.etree.elementtree.md#module-xml.etree.ElementTree "xml.etree.ElementTree: Implementation of the ElementTree API."): 现在该模块在对 [`xml.etree.ElementTree.Element`](../library/xml.etree.elementtree.md#xml.etree.ElementTree.Element "xml.etree.ElementTree.Element") 进行真值测试时将发出 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 在之前，Python 实现会发出 [`FutureWarning`](../library/exceptions.md#FutureWarning "FutureWarning")，而 C 实现则不会发出任何警告。

  * [`throw()`](../reference/datamodel.md#coroutine.throw "coroutine.throw"), [`throw()`](../reference/expressions.md#generator.throw "generator.throw") 和 [`athrow()`](../reference/expressions.md#agen.athrow "agen.athrow") 的 3 参数签名 (type, value, traceback) 已被弃用并可能在未来的 Python 版本中被移除。 请改用这些函数的单参数版本。 （由 Ofey Chan 在 [gh-89874](https://github.com/python/cpython/issues/89874) 中贡献。）

  * 现在当一个模块上的 `__package__` 不同于 `__spec__.parent` 时将引发 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning") (在之前版本中则为 [`ImportWarning`](../library/exceptions.md#ImportWarning "ImportWarning"))。 （由 Brett Cannon 在 [gh-65961](https://github.com/python/cpython/issues/65961) 中贡献。）

  * 根据 [**PEP 699**](https://peps.python.org/pep-0699/) 的要求，[`PyDictObject`](../c-api/dict.md#c.PyDictObject "PyDictObject") 中的 `ma_version_tag` 字段对于扩展模块已被弃用。 访问该字段将在编译时生成编译器警告。 该字段将在 Python 3.14 中移除。 （由 Ramvikrams 和 Kumar Aditya 在 [gh-101193](https://github.com/python/cpython/issues/101193) 中贡献。 PEP 由 Ken Jin 撰写。）

  * 用于布尔值的按位取反运算符 (`~`) 已被弃用。 它在 Python 3.14 中将抛出错误。 请改用 `not` 执行布尔值的逻辑非运算。 在你确实需要对下层的 `int` 执行取反运算的少数场景下，请显式地通过 `~int(x)` 将其转换为整数值。 （由 Tim Hoffmann 在 [gh-103487](https://github.com/python/cpython/issues/103487) 中贡献。）

### 计划在 Python 3.13 中移除¶

以下模块和 API 已在之前的 Python 发布版中弃用，并将在 Python 3.13 中移除。

模块 (参见 [**PEP 594**](https://peps.python.org/pep-0594/)):

  * `aifc`

  * `audioop`

  * `cgi`

  * `cgitb`

  * `chunk`

  * `crypt`

  * `imghdr`

  * `mailcap`

  * `msilib`

  * `nis`

  * `nntplib`

  * `ossaudiodev`

  * `pipes`

  * `sndhdr`

  * `spwd`

  * `sunau`

  * `telnetlib`

  * `uu`

  * `xdrlib`

其他模块：

  * `lib2to3`，以及 **2to3** 程序 ([gh-84540](https://github.com/python/cpython/issues/84540))

API:

  * `configparser.LegacyInterpolation` ([gh-90765](https://github.com/python/cpython/issues/90765))

  * [`locale.getdefaultlocale()`](../library/locale.md#locale.getdefaultlocale "locale.getdefaultlocale") ([gh-90817](https://github.com/python/cpython/issues/90817))

  * `locale.resetlocale()` ([gh-90817](https://github.com/python/cpython/issues/90817))

  * `turtle.RawTurtle.settiltangle()` ([gh-50096](https://github.com/python/cpython/issues/50096))

  * `unittest.findTestCases()` ([gh-50096](https://github.com/python/cpython/issues/50096))

  * `unittest.getTestCaseNames()` ([gh-50096](https://github.com/python/cpython/issues/50096))

  * `unittest.makeSuite()` ([gh-50096](https://github.com/python/cpython/issues/50096))

  * `unittest.TestProgram.usageExit()` ([gh-67048](https://github.com/python/cpython/issues/67048))

  * `webbrowser.MacOSX` ([gh-86421](https://github.com/python/cpython/issues/86421))

  * [`classmethod`](../library/functions.md#classmethod "classmethod") 描述器串联 ([gh-89519](https://github.com/python/cpython/issues/89519))

### 计划在 Python 3.14 中移除¶

  * [`argparse`](../library/argparse.md#module-argparse "argparse: Command-line option and argument parsing library."): `argparse.BooleanOptionalAction` 的 _type_ , _choices_ 和 _metavar_ 形参已被弃用并将在 3.14 中移除。 （由 Nikita Sobolev 在 [gh-92248](https://github.com/python/cpython/issues/92248) 中贡献。）

  * [`ast`](../library/ast.md#module-ast "ast: Abstract Syntax Tree classes and manipulation."): 以下 [`ast`](../library/ast.md#module-ast "ast: Abstract Syntax Tree classes and manipulation.") 特性自 Python 3.8 起已在文档中声明弃用，现在当运行时如果它们被访问或使用将发出 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")，并将在 Python 3.14 中移除:

    * `ast.Num`

    * `ast.Str`

    * `ast.Bytes`

    * `ast.NameConstant`

    * `ast.Ellipsis`

请改用 [`ast.Constant`](../library/ast.md#ast.Constant "ast.Constant")。 （由 Serhiy Storchaka 在 [gh-90953](https://github.com/python/cpython/issues/90953) 中贡献。）

  * [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O."): [`asyncio.Future.cancel()`](../library/asyncio-future.md#asyncio.Future.cancel "asyncio.Future.cancel") 和 [`asyncio.Task.cancel()`](../library/asyncio-task.md#asyncio.Task.cancel "asyncio.Task.cancel") 的 _msg_ 形参 ([gh-90985](https://github.com/python/cpython/issues/90985))

  * [`collections.abc`](../library/collections.abc.md#module-collections.abc "collections.abc: Abstract base classes for containers"): 已弃用 [`collections.abc.ByteString`](../library/collections.abc.md#collections.abc.ByteString "collections.abc.ByteString")。 推荐改用 `Sequence` 或 [`collections.abc.Buffer`](../library/collections.abc.md#collections.abc.Buffer "collections.abc.Buffer")。 在类型标中，推荐改用并集，如 `bytes | bytearray` 或 [`collections.abc.Buffer`](../library/collections.abc.md#collections.abc.Buffer "collections.abc.Buffer")。 （由 Shantanu Jain 在 [gh-91896](https://github.com/python/cpython/issues/91896) 中贡献。）

  * [`email`](../library/email.md#module-email "email: Package supporting the parsing, manipulating, and generating email messages."): 已弃用 [`email.utils.localtime()`](../library/email.utils.md#email.utils.localtime "email.utils.localtime") 中的 _isdst_ 形参。 （由 Alan Williams 在 [gh-72346](https://github.com/python/cpython/issues/72346) 中贡献。）

  * [`importlib.abc`](../library/importlib.md#module-importlib.abc "importlib.abc: Abstract base classes related to import"): 已弃用下列类，计划在 Python 3.14 中移除:

    * `importlib.abc.ResourceReader`

    * `importlib.abc.Traversable`

    * `importlib.abc.TraversableResources`

使用 [`importlib.resources.abc`](../library/importlib.resources.abc.md#module-importlib.resources.abc "importlib.resources.abc: Abstract base classes for resources") 类代替:

    * [`importlib.resources.abc.Traversable`](../library/importlib.resources.abc.md#importlib.resources.abc.Traversable "importlib.resources.abc.Traversable")

    * [`importlib.resources.abc.TraversableResources`](../library/importlib.resources.abc.md#importlib.resources.abc.TraversableResources "importlib.resources.abc.TraversableResources")

（由 Jason R. Coombs 和 Hugo van Kemenade 在 [gh-93963](https://github.com/python/cpython/issues/93963) 中贡献。）

  * [`itertools`](../library/itertools.md#module-itertools "itertools: Functions creating iterators for efficient looping."): 该模块具有对 copy, deepcopy 和 pickle 等操作的未写入文档的、低效的、历史上充满问题的且不稳定的支持。 这将在 3.14 中移除以显著减少代码量和维护负担。 （由 Raymond Hettinger 在 [gh-101588](https://github.com/python/cpython/issues/101588) 中贡献。）

  * [`multiprocessing`](../library/multiprocessing.md#module-multiprocessing "multiprocessing: Process-based parallelism."): 默认的 [`multiprocessing`](../library/multiprocessing.md#module-multiprocessing "multiprocessing: Process-based parallelism.") 启动方法在目前默认使用 `'fork'` 的 Linux, BSD 和其他非 macOS 的 POSIX 平台上将改为更安全的启动方法 ([gh-84559](https://github.com/python/cpython/issues/84559))。 为此添加运行时警告将带来糟糕的体验因为大部分代码并不会关心这个问题。 当你的代码 _需要_ `'fork'` 时请使用 [`get_context()`](../library/multiprocessing.md#multiprocessing.get_context "multiprocessing.get_context") 或 [`set_start_method()`](../library/multiprocessing.md#multiprocessing.set_start_method "multiprocessing.set_start_method") API 来显式地指明。 参见 [上下文和启动方法](../library/multiprocessing.md#multiprocessing-start-methods)。

  * [`pkgutil`](../library/pkgutil.md#module-pkgutil "pkgutil: Utilities for the import system."): 现在 [`pkgutil.find_loader()`](../library/pkgutil.md#pkgutil.find_loader "pkgutil.find_loader") 和 [`pkgutil.get_loader()`](../library/pkgutil.md#pkgutil.get_loader "pkgutil.get_loader") 将引发 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")；请改用 [`importlib.util.find_spec()`](../library/importlib.md#importlib.util.find_spec "importlib.util.find_spec")。 （由 Nikita Sobolev 在 [gh-97850](https://github.com/python/cpython/issues/97850) 中贡献。）

  * [`pty`](../library/pty.md#module-pty "pty: Pseudo-Terminal Handling for Unix. \(Unix\)"): 该模块有两个未写入文档的 `master_open()` 和 `slave_open()` 函数自 Python 2 起即已被弃用但直到 3.12 才添加了相应的 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 它们将在 3.14 中移除。

  * [`shutil`](../library/shutil.md#module-shutil "shutil: High-level file operations, including copying."): [`shutil.rmtree()`](../library/shutil.md#shutil.rmtree "shutil.rmtree") 的 _onerror_ 参数在 3.12 中已被弃用，并将在 3.14 中移除。

  * [`typing`](../library/typing.md#module-typing "typing: Support for type hints \(see :pep:`484`\)."): [`typing.ByteString`](../library/typing.md#typing.ByteString "typing.ByteString") 自 Python 3.9 起已被弃用，现在当被使用时将会发出 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。

  * [`xml.etree.ElementTree`](../library/xml.etree.elementtree.md#module-xml.etree.ElementTree "xml.etree.ElementTree: Implementation of the ElementTree API."): 已弃用对 [`xml.etree.ElementTree.Element`](../library/xml.etree.elementtree.md#xml.etree.ElementTree.Element "xml.etree.ElementTree.Element") 进行真值测试并将在 Python 3.14 中引发异常。

  * 使用 C API 创建以可变类为基类的不可变类型 ([`Py_TPFLAGS_IMMUTABLETYPE`](../c-api/typeobj.md#c.Py_TPFLAGS_IMMUTABLETYPE "Py_TPFLAGS_IMMUTABLETYPE")) ([gh-95388](https://github.com/python/cpython/issues/95388))。

  * `__package__` 和 `__cached__` 将不再被设置或是被导入系统纳入考量 ([gh-97879](https://github.com/python/cpython/issues/97879))。

  * 对 `co_lnotab` 的访问自 3.10 起已在 [**PEP 626**](https://peps.python.org/pep-0626/) 中被弃用并原定在 3.12 中移除，但实际上在 3.12 中仅添加了 [`DeprecationWarning`](../library/exceptions.md#DeprecationWarning "DeprecationWarning")。 可能会在 3.14 中移除。 （由 Nikita Sobolev 在 [gh-101866](https://github.com/python/cpython/issues/101866) 中贡献。）

  * 使用 C API 创建以可变类为基类的 [`不可变类型`](../c-api/typeobj.md#c.Py_TPFLAGS_IMMUTABLETYPE "Py_TPFLAGS_IMMUTABLETYPE") ([gh-95388](https://github.com/python/cpython/issues/95388))

### 计划在未来版本中移除¶

下列 API 在更早的 Python 版本中已被弃用并将被移除，但目前还没有确定它们的移除日期。

  * [`array`](../library/array.md#module-array "array: Space efficient arrays of uniformly typed numeric values.") 的 `'u'` 格式代码 ([gh-57281](https://github.com/python/cpython/issues/57281))

  * [`typing.Text`](../library/typing.md#typing.Text "typing.Text") ([gh-92332](https://github.com/python/cpython/issues/92332))

  * 目前 Python 接受数字类字面值后面紧跟关键字的写法，例如 `0in x`, `1or x`, `0if 1else 2`。 它将允许像 `[0x1for x in y]` 这样令人困惑且模棱两可的表达式 (它可以被解读为 `[0x1 for x in y]` 或者 `[0x1f or x in y]`)。 从本发布版开始，如果数字类字面值后面紧跟关键字 [`and`](../reference/expressions.md#and), [`else`](../reference/compound_stmts.md#else), [`for`](../reference/compound_stmts.md#for), [`if`](../reference/compound_stmts.md#if), [`in`](../reference/expressions.md#in), [`is`](../reference/expressions.md#is) 和 [`or`](../reference/expressions.md#or) 中的一个将会引发弃用警告。 在未来的版本中它将改为语法警告，最终将改为语法错误。 ([gh-87999](https://github.com/python/cpython/issues/87999))

## 移除¶

### asynchat 和 asyncore¶

  * 这两个模块已根据 [**PEP 594**](https://peps.python.org/pep-0594/) 中的时间表被移除，它们从 Python 3.6 起已被弃用。 请改用 [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O.")。 （由 Nikita Sobolev 在 [gh-96580](https://github.com/python/cpython/issues/96580) 中贡献。）

### configparser¶

  * [`configparser`](../library/configparser.md#module-configparser "configparser: Configuration file parser.") 中的几个从 3.2 起已被弃用的名称已根据 [gh-89336](https://github.com/python/cpython/issues/89336) 被移除：

    * [`configparser.ParsingError`](../library/configparser.md#configparser.ParsingError "configparser.ParsingError") 不再具有 `filename` 属性或参数。 请改用 `source` 属性和参数。

    * [`configparser`](../library/configparser.md#module-configparser "configparser: Configuration file parser.") 不再具有 `SafeConfigParser` 类。 请改用更简短的名称 [`ConfigParser`](../library/configparser.md#configparser.ConfigParser "configparser.ConfigParser")。

    * [`configparser.ConfigParser`](../library/configparser.md#configparser.ConfigParser "configparser.ConfigParser") 不再具有 `readfp` 方法。 请改用 [`read_file()`](../library/configparser.md#configparser.ConfigParser.read_file "configparser.ConfigParser.read_file")。

### distutils¶

  * 移除了 `distutils` 包。 它已在 Python 3.10 中根据 [**PEP 632**](https://peps.python.org/pep-0632/) "Deprecate distutils module" 被弃用。 对于仍然使用 `distutils` 且无法升级为使用其他工具的项目，可以安装 `setuptools` 项目：它仍然提供了 `distutils`。 （由 Victor Stinner 在 [gh-92584](https://github.com/python/cpython/issues/92584) 中贡献。）

### ensurepip¶

  * 从 [`ensurepip`](../library/ensurepip.md#module-ensurepip "ensurepip: Bootstrapping the "pip" installer into an existing Python installation or virtual environment.") 中移除了捆绑的 setuptools wheel，并停止在由 [`venv`](../library/venv.md#module-venv "venv: Creation of virtual environments.") 创建的环境中安装 setuptools。

`pip (>= 22.1)` 不再要求在环境中安装 setuptools。 基于 `setuptools` (和基于 `distutils`) 的包仍然可通过 `pip install` 来使用，因为 pip 将在它用于构建包的构建环境中提供 `setuptools`。

在默认情况下由 `venv` 创建或通过 `ensurepip` 初始化的环境将不再提供 `easy_install`, `pkg_resources`, `setuptools` 和 `distutils` 包，因为它们是 `setuptools` 包的组成部分。 对于在运行时依赖这些包的项目，应当将 `setuptools` 项目声明为依赖项之一并单独安装（通常是使用 pip）。

（由 Pradyun Gedam 在 [gh-95299](https://github.com/python/cpython/issues/95299) 中贡献。）

### enum¶

  * 移除了 [`enum`](../library/enum.md#module-enum "enum: Implementation of an enumeration class.") 的 `EnumMeta.__getattr__`，枚举属性访问已不再需要它。 （由 Ethan Furman 在 [gh-95083](https://github.com/python/cpython/issues/95083) 中贡献。）

### ftplib¶

  * Remove [`ftplib`](../library/ftplib.md#module-ftplib "ftplib: FTP protocol client \(requires sockets\).")'s `FTP_TLS.ssl_version` class attribute: use the _context_ parameter instead. (Contributed by Victor Stinner in [gh-94172](https://github.com/python/cpython/issues/94172).)

### gzip¶

  * Remove the `filename` attribute of [`gzip`](../library/gzip.md#module-gzip "gzip: Interfaces for gzip compression and decompression using file objects.")'s [`gzip.GzipFile`](../library/gzip.md#gzip.GzipFile "gzip.GzipFile"), deprecated since Python 2.6, use the [`name`](../library/gzip.md#gzip.GzipFile.name "gzip.GzipFile.name") attribute instead. In write mode, the `filename` attribute added `'.gz'` file extension if it was not present. (Contributed by Victor Stinner in [gh-94196](https://github.com/python/cpython/issues/94196).)

### hashlib¶

  * Remove the pure Python implementation of [`hashlib`](../library/hashlib.md#module-hashlib "hashlib: Secure hash and message digest algorithms.")'s [`hashlib.pbkdf2_hmac()`](../library/hashlib.md#hashlib.pbkdf2_hmac "hashlib.pbkdf2_hmac"), deprecated in Python 3.10. Python 3.10 and newer requires OpenSSL 1.1.1 ([ **PEP 644**](https://peps.python.org/pep-0644/)): this OpenSSL version provides a C implementation of [`pbkdf2_hmac()`](../library/hashlib.md#hashlib.pbkdf2_hmac "hashlib.pbkdf2_hmac") which is faster. (Contributed by Victor Stinner in [gh-94199](https://github.com/python/cpython/issues/94199).)

### importlib¶

  * Many previously deprecated cleanups in [`importlib`](../library/importlib.md#module-importlib "importlib: The implementation of the import machinery.") have now been completed:

    * 对 `module_repr()` 的引用和支持已被移除。 （由 Barry Warsaw 在 [gh-97850](https://github.com/python/cpython/issues/97850) 中贡献。）

    * `importlib.util.set_package`, `importlib.util.set_loader` 和 `importlib.util.module_for_loader` 均已被移除。 （由 Brett Cannon 和 Nikita Sobolev 在 [gh-65961](https://github.com/python/cpython/issues/65961) 和 [gh-97850](https://github.com/python/cpython/issues/97850) 中贡献。）

    * 对 `find_loader()` 和 `find_module()` API 的支持已被移除。 （由 Barry Warsaw 在 [gh-98040](https://github.com/python/cpython/issues/98040) 中贡献。）

    * `importlib.abc.Finder`, `pkgutil.ImpImporter` 和 `pkgutil.ImpLoader` 已被移除。 （由 Barry Warsaw 在 [gh-98040](https://github.com/python/cpython/issues/98040) 中贡献。）

### imp¶

  * `imp` 模块已被移除。 （由 Barry Warsaw 在 [gh-98040](https://github.com/python/cpython/issues/98040) 中贡献。）

  * 将已移除的 `imp` 函数替换为 [`importlib`](../library/importlib.md#module-importlib "importlib: The implementation of the import machinery.") 函数:

> imp
>
> |
>
> importlib  
>  
> ---|---  
>  
> `imp.NullImporter`
>
> |
>
> 将 `None` 插入到 `sys.path_importer_cache`  
>  
> `imp.cache_from_source()`
>
> |
>
> [`importlib.util.cache_from_source()`](../library/importlib.md#importlib.util.cache_from_source "importlib.util.cache_from_source")  
>  
> `imp.find_module()`
>
> |
>
> [`importlib.util.find_spec()`](../library/importlib.md#importlib.util.find_spec "importlib.util.find_spec")  
>  
> `imp.get_magic()`
>
> |
>
> [`importlib.util.MAGIC_NUMBER`](../library/importlib.md#importlib.util.MAGIC_NUMBER "importlib.util.MAGIC_NUMBER")  
>  
> `imp.get_suffixes()`
>
> |
>
> [`importlib.machinery.SOURCE_SUFFIXES`](../library/importlib.md#importlib.machinery.SOURCE_SUFFIXES "importlib.machinery.SOURCE_SUFFIXES"), [`importlib.machinery.EXTENSION_SUFFIXES`](../library/importlib.md#importlib.machinery.EXTENSION_SUFFIXES "importlib.machinery.EXTENSION_SUFFIXES") 和 [`importlib.machinery.BYTECODE_SUFFIXES`](../library/importlib.md#importlib.machinery.BYTECODE_SUFFIXES "importlib.machinery.BYTECODE_SUFFIXES")  
>  
> `imp.get_tag()`
>
> |
>
> [`sys.implementation.cache_tag`](../library/sys.md#sys.implementation "sys.implementation")  
>  
> `imp.load_module()`
>
> |
>
> [`importlib.import_module()`](../library/importlib.md#importlib.import_module "importlib.import_module")  
>  
> `imp.new_module(name)`
>
> |
>
> `types.ModuleType(name)`  
>  
> `imp.reload()`
>
> |
>
> [`importlib.reload()`](../library/importlib.md#importlib.reload "importlib.reload")  
>  
> `imp.source_from_cache()`
>
> |
>
> [`importlib.util.source_from_cache()`](../library/importlib.md#importlib.util.source_from_cache "importlib.util.source_from_cache")  
  
  * 将 `imp.load_source()` 替换为:
    
        import importlib.util
    import importlib.machinery
    
    def load_source(modname, filename):
        loader = importlib.machinery.SourceFileLoader(modname, filename)
        spec = importlib.util.spec_from_file_location(modname, filename, loader=loader)
        module = importlib.util.module_from_spec(spec)
        # The module is always executed and not cached in sys.modules.
        # Uncomment the following line to cache the module.
        # sys.modules[module.__name__] = module
        loader.exec_module(module)
        return module
    

  * 已移除 `imp` 函数和属性并且没有替选项:

    * 未写入文档的函数:

      * `imp.init_builtin()`

      * `imp.load_compiled()`

      * `imp.load_dynamic()`

      * `imp.load_package()`

    * `imp.lock_held()`,``imp.acquire_lock()``,``imp.release_lock()``: 加锁方案在 Python 3.3 中已改为模块级锁。

    * `imp.find_module()` 常量: `SEARCH_ERROR`, `PY_SOURCE`, `PY_COMPILED`, `C_EXTENSION`, `PY_RESOURCE`, `PKG_DIRECTORY`, `C_BUILTIN`, `PY_FROZEN`, `PY_CODERESOURCE`, `IMP_HOOK`。

### io¶

  * Remove [`io`](../library/io.md#module-io "io: Core tools for working with streams.")'s `io.OpenWrapper` and `_pyio.OpenWrapper`, deprecated in Python 3.10: just use [`open()`](../library/functions.md#open "open") instead. The [`open()`](../library/functions.md#open "open") ([`io.open()`](../library/io.md#io.open "io.open")) function is a built-in function. Since Python 3.10, `_pyio.open()` is also a static method. (Contributed by Victor Stinner in [gh-94169](https://github.com/python/cpython/issues/94169).)

### locale¶

  * Remove [`locale`](../library/locale.md#module-locale "locale: Internationalization services.")'s `locale.format()` function, deprecated in Python 3.7: use [`locale.format_string()`](../library/locale.md#locale.format_string "locale.format_string") instead. (Contributed by Victor Stinner in [gh-94226](https://github.com/python/cpython/issues/94226).)

  * `smtpd`: 该模块已按照 [**PEP 594**](https://peps.python.org/pep-0594/) 中的计划表被移除，它在 Python 3.4.7 和 3.5.4 中已被弃用。 请改用 [aiosmtpd](https://pypi.org/project/aiosmtpd/) PyPI 模块或任何其他基于 [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O.") Oleg Iarygin 在 [gh-93243](https://github.com/python/cpython/issues/93243) 中贡献。）

### sqlite3¶

  * The following undocumented [`sqlite3`](../library/sqlite3.md#module-sqlite3 "sqlite3: A DB-API 2.0 implementation using SQLite 3.x.") features, deprecated in Python 3.10, are now removed:

    * `sqlite3.enable_shared_cache()`

    * `sqlite3.OptimizedUnicode`

如果必须使用共享缓存，请在以 URI 模式打开数据库时使用 `cache=shared` 查询参数。

`sqlite3.OptimizedUnicode` 文本工厂函数自 Python 3.3 起已成为 [`str`](../library/stdtypes.md#str "str") 的一个别名。 之前将文本工厂设为 `OptimizedUnicode` 的代码可以显式地使用 `str`，或者依赖同样为 `str` 的默认值。

（由 Erlend E. Aasland 在 [gh-92548](https://github.com/python/cpython/issues/92548) 中贡献。）

### ssl¶

  * Remove [`ssl`](../library/ssl.md#module-ssl "ssl: TLS/SSL wrapper for socket objects")'s `ssl.RAND_pseudo_bytes()` function, deprecated in Python 3.6: use [`os.urandom()`](../library/os.md#os.urandom "os.urandom") or [`ssl.RAND_bytes()`](../library/ssl.md#ssl.RAND_bytes "ssl.RAND_bytes") instead. (Contributed by Victor Stinner in [gh-94199](https://github.com/python/cpython/issues/94199).)

  * 移除了 `ssl.match_hostname()` 函数。 它在 Python 3.7 中已被弃用。 OpenSSL 自 Python 3.7 起将会执行主机名匹配，Python 已不再使用 `ssl.match_hostname()` 函数。 （由 Victor Stinner 在 [gh-94199](https://github.com/python/cpython/issues/94199) 中贡献。）

  * 移除了 `ssl.wrap_socket()` 函数，它在 Python 3.7 中已被弃用：请改为创建一个 [`ssl.SSLContext`](../library/ssl.md#ssl.SSLContext "ssl.SSLContext") 对象并调用其 [`ssl.SSLContext.wrap_socket`](../library/ssl.md#ssl.SSLContext.wrap_socket "ssl.SSLContext.wrap_socket") 方法。 任何仍然使用 `ssl.wrap_socket()` 的包都不再适用并且是不安全的。 该函数既不会发送 SNI TLS 扩展也不会验证服务器主机名。 其代码会受到 [CWE-295](https://cwe.mitre.org/data/definitions/295.md): 不正确的证书验证问题的影响。 （由 Victor Stinner 在 [gh-94199](https://github.com/python/cpython/issues/94199) 中贡献。）

### unittest¶

  * 移除了许多早已弃用的 [`unittest`](../library/unittest.md#module-unittest "unittest: Unit testing framework for Python.") 特性:

    * 一些 [`TestCase`](../library/unittest.md#unittest.TestCase "unittest.TestCase") 方法的别名:

已弃用的别名

|

方法名

|

弃用于  
  
---|---|---  
  
`failUnless`

|

[`assertTrue()`](../library/unittest.md#unittest.TestCase.assertTrue "unittest.TestCase.assertTrue")

|

3.1  
  
`failIf`

|

[`assertFalse()`](../library/unittest.md#unittest.TestCase.assertFalse "unittest.TestCase.assertFalse")

|

3.1  
  
`failUnlessEqual`

|

[`assertEqual()`](../library/unittest.md#unittest.TestCase.assertEqual "unittest.TestCase.assertEqual")

|

3.1  
  
`failIfEqual`

|

[`assertNotEqual()`](../library/unittest.md#unittest.TestCase.assertNotEqual "unittest.TestCase.assertNotEqual")

|

3.1  
  
`failUnlessAlmostEqual`

|

[`assertAlmostEqual()`](../library/unittest.md#unittest.TestCase.assertAlmostEqual "unittest.TestCase.assertAlmostEqual")

|

3.1  
  
`failIfAlmostEqual`

|

[`assertNotAlmostEqual()`](../library/unittest.md#unittest.TestCase.assertNotAlmostEqual "unittest.TestCase.assertNotAlmostEqual")

|

3.1  
  
`failUnlessRaises`

|

[`assertRaises()`](../library/unittest.md#unittest.TestCase.assertRaises "unittest.TestCase.assertRaises")

|

3.1  
  
`assert_`

|

[`assertTrue()`](../library/unittest.md#unittest.TestCase.assertTrue "unittest.TestCase.assertTrue")

|

3.2  
  
`assertEquals`

|

[`assertEqual()`](../library/unittest.md#unittest.TestCase.assertEqual "unittest.TestCase.assertEqual")

|

3.2  
  
`assertNotEquals`

|

[`assertNotEqual()`](../library/unittest.md#unittest.TestCase.assertNotEqual "unittest.TestCase.assertNotEqual")

|

3.2  
  
`assertAlmostEquals`

|

[`assertAlmostEqual()`](../library/unittest.md#unittest.TestCase.assertAlmostEqual "unittest.TestCase.assertAlmostEqual")

|

3.2  
  
`assertNotAlmostEquals`

|

[`assertNotAlmostEqual()`](../library/unittest.md#unittest.TestCase.assertNotAlmostEqual "unittest.TestCase.assertNotAlmostEqual")

|

3.2  
  
`assertRegexpMatches`

|

[`assertRegex()`](../library/unittest.md#unittest.TestCase.assertRegex "unittest.TestCase.assertRegex")

|

3.2  
  
`assertRaisesRegexp`

|

[`assertRaisesRegex()`](../library/unittest.md#unittest.TestCase.assertRaisesRegex "unittest.TestCase.assertRaisesRegex")

|

3.2  
  
`assertNotRegexpMatches`

|

[`assertNotRegex()`](../library/unittest.md#unittest.TestCase.assertNotRegex "unittest.TestCase.assertNotRegex")

|

3.5  
  
您可以使用 <https://github.com/isidentical/teyit> 来自动更新你的单元测试。

    * 未写入文档且已不可用的 [`TestCase`](../library/unittest.md#unittest.TestCase "unittest.TestCase") 方法 `assertDictContainsSubset`。 （在 Python 3.2 中已弃用。）

    * 未写入文档的 [`TestLoader.loadTestsFromModule`](../library/unittest.md#unittest.TestLoader.loadTestsFromModule "unittest.TestLoader.loadTestsFromModule") 形参 _use_load_tests_ 。 （自 Python 3.2 起已弃用并被忽略。）

    * [`TextTestResult`](../library/unittest.md#unittest.TextTestResult "unittest.TextTestResult") 类的一个别名: `_TextTestResult`。 （在 Python 3.2 中已弃用。）

（由 Serhiy Storchaka 在 [bpo-45162](https://bugs.python.org/issue?@action=redirect&bpo=45162) 中贡献。）

### webbrowser¶

  * 从 [`webbrowser`](../library/webbrowser.md#module-webbrowser "webbrowser: Easy-to-use controller for web browsers.") 移除了对过时浏览器的支持。 被移除的浏览器包括: Grail, Mosaic, Netscape, Galeon, Skipstone, Iceape, Firebird 和 Firefox 35 及以下的版本 ([gh-102871](https://github.com/python/cpython/issues/102871))。

### xml.etree.ElementTree¶

  * 移除了纯 Python 实现的 `ElementTree.Element.copy()` 方法，该方法在 Python 3.10 中已被弃用，请改用 [`copy.copy()`](../library/copy.md#copy.copy "copy.copy") 函数。 [`xml.etree.ElementTree`](../library/xml.etree.elementtree.md#module-xml.etree.ElementTree "xml.etree.ElementTree: Implementation of the ElementTree API.") 的 C 实现没有 `copy()` 方法，只有 `__copy__()` 方法。 （由 Victor Stinner 在 [gh-94383](https://github.com/python/cpython/issues/94383) 中贡献。）

### zipimport¶

  * Remove [`zipimport`](../library/zipimport.md#module-zipimport "zipimport: Support for importing Python modules from ZIP archives.")'s `find_loader()` and `find_module()` methods, deprecated in Python 3.10: use the `find_spec()` method instead. See [**PEP 451**](https://peps.python.org/pep-0451/) for the rationale. (Contributed by Victor Stinner in [gh-94379](https://github.com/python/cpython/issues/94379).)

### 其他事项¶

  * 从文档 Makefile 中移除了 `suspicious` 规则，并移除了 `Doc/tools/rstlint.py`，请改用 [sphinx-lint](https://github.com/sphinx-contrib/sphinx-lint)。 （由 Julien Palard 在 [gh-98179](https://github.com/python/cpython/issues/98179) 中贡献。）

  * 移除了 [`ftplib`](../library/ftplib.md#module-ftplib "ftplib: FTP protocol client \(requires sockets\).")、[`imaplib`](../library/imaplib.md#module-imaplib "imaplib: IMAP4 protocol client \(requires sockets\).")、[`poplib`](../library/poplib.md#module-poplib "poplib: POP3 protocol client \(requires sockets\).") 和 [`smtplib`](../library/smtplib.md#module-smtplib "smtplib: SMTP protocol client \(requires sockets\).") 模块中的 _keyfile_ 和 _certfile_ 形参数，以及 [`http.client`](../library/http.client.md#module-http.client "http.client: HTTP and HTTPS protocol client \(requires sockets\).") 模块中的 _key_file_ 、 _cert_file_ 和 _check_hostname_ 形参，它们自 Python 3.6 起都已被弃用。 请改用 _context_ 形参（在 [`imaplib`](../library/imaplib.md#module-imaplib "imaplib: IMAP4 protocol client \(requires sockets\).") 中为 _ssl_context_ 形参）。 （由 Victor Stinner 在 [gh-94172](https://github.com/python/cpython/issues/94172) 中贡献。）.)

## 移植到 Python 3.12¶

本节列出了先前描述的更改以及可能需要更改代码的其他错误修正.

### Python API 的变化¶

  * 现在对于正则表达式中的数字分组引用和分组名称将应用更严格的规则。 现在只接受 ASCII 数字序列作为数字引用。 字节串模式和替换字符串中的分组名称现在只能包含 ASCII 字母、数字和下划线。 （由 Serhiy Storchaka 在 [gh-91760](https://github.com/python/cpython/issues/91760) 中贡献。）

  * 移除了自 Python 3.10 起已被弃用的 `randrange()` 功能。 以前，`randrange(10.0)` 会无损地转换为 `randrange(10)`。 现在，它将引发 [`TypeError`](../library/exceptions.md#TypeError "TypeError")。 此外，对于非整数值如 `randrange(10.5)` 或 `randrange('10')` 所引发的异常已从 [`ValueError`](../library/exceptions.md#ValueError "ValueError") 改为 [`TypeError`](../library/exceptions.md#TypeError "TypeError")。 这也防止了 `randrange(1e25)` 会从比 `randrange(10**25)` 更大的范围中静默选择的问题。 （最初由 Serhiy Storchaka 在 [gh-86388](https://github.com/python/cpython/issues/86388) 中提议。）

  * [`argparse.ArgumentParser`](../library/argparse.md#argparse.ArgumentParser "argparse.ArgumentParser") 将从文件（例如 `fromfile_prefix_chars` 选项）读取参数的编码格式和错误处理句柄从默认的文本编码格式（例如 [`locale.getpreferredencoding(False)`](../library/locale.md#locale.getpreferredencoding "locale.getpreferredencoding") 调用）改为 [filesystem encoding and error handler](../glossary.md#term-filesystem-encoding-and-error-handler)。 在 Windows 系统中参数文件应使用 UTF-8 而不是 ANSI 代码页来编码。

  * 删除了在 Python 3.4.7 和 3.5.4 中已被弃用的 `asyncore`-based `smtpd` 模块。 推荐使用基于 [`asyncio`](../library/asyncio.md#module-asyncio "asyncio: Asynchronous I/O.") 的 [aiosmtpd](https://pypi.org/project/aiosmtpd/) PyPI 模块来替代。

  * [`shlex.split()`](../library/shlex.md#shlex.split "shlex.split"): 传入 `None` 作为 _s_ 参数现在将引发异常，而不是读取 [`sys.stdin`](../library/sys.md#sys.stdin "sys.stdin")。 该特性在 Python 3.9 中已被弃用。 （由 Victor Stinner 在 [gh-94352](https://github.com/python/cpython/issues/94352) 中贡献。）

  * [`os`](../library/os.md#module-os "os: Miscellaneous operating system interfaces.") 模块不再接受类似字节串的路径，如 [`bytearray`](../library/stdtypes.md#bytearray "bytearray") 和 [`memoryview`](../library/stdtypes.md#memoryview "memoryview") 类型：只接受明确的 [`bytes`](../library/stdtypes.md#bytes "bytes") 类型字节串。 （由 Victor Stinner 在 [gh-98393](https://github.com/python/cpython/issues/98393) 中贡献。）

  * 现在 [`syslog.openlog()`](../library/syslog.md#syslog.openlog "syslog.openlog") 和 [`syslog.closelog()`](../library/syslog.md#syslog.closelog "syslog.closelog") 如果在子解释器中使用将失败。 [`syslog.syslog()`](../library/syslog.md#syslog.syslog "syslog.syslog") 仍可在子解释器中使用，但前提是 [`syslog.openlog()`](../library/syslog.md#syslog.openlog "syslog.openlog") 已在主解释器中被调用。 这些新限制不适用于主解释器，因此只有少数用户可能会受到影响。 这一改变有助于实现解释器隔离。 此外， [`syslog`](../library/syslog.md#module-syslog "syslog: An interface to the Unix syslog library routines. \(Unix\)") 是一个针对进程全局资源的包装器，而这些资源最好是通过主解释器来管理。 （由 Dong-hee Na 在 [gh-99127](https://github.com/python/cpython/issues/99127) 中贡献。）

  * 未写入文档的 [`cached_property()`](../library/functools.md#functools.cached_property "functools.cached_property") 的锁定行为已被移除，因为该行为会在类的所有实例中锁定，从而导致高锁定争用。 这意味着如果两个线程同时运行，缓存属性获取函数现在可以在单个实例中运行不止一次。 对于大多数简单的缓存属性（例如那些幂等的并且只需根据实例的其他属性计算一个值的属性）来说这是没有问题的。 如果需要同步，可在缓存属性获取函数中或多线程访问点周围实现锁定操作。

  * 现在 [`sys._current_exceptions()`](../library/sys.md#sys._current_exceptions "sys._current_exceptions") 将返回从线程 ID 到异常实例的映射，而不是到 `(typ, exc, tb)` 元组的映射。 （由 Irit Katriel 在 [gh-103176](https://github.com/python/cpython/issues/103176) 中贡献。）

  * 当使用 [`tarfile`](../library/tarfile.md#module-tarfile "tarfile: Read and write tar-format archive files.") 或 [`shutil.unpack_archive()`](../library/shutil.md#shutil.unpack_archive "shutil.unpack_archive") 提取 tar 文件时，请传入 _filter_ 参数来限制可能令人感到意外或危险的特性。 请参阅 [解压缩过滤器](../library/tarfile.md#tarfile-extraction-filter) 了解详情。

  * The output of the [`tokenize.tokenize()`](../library/tokenize.md#tokenize.tokenize "tokenize.tokenize") and [`tokenize.generate_tokens()`](../library/tokenize.md#tokenize.generate_tokens "tokenize.generate_tokens") functions is now changed due to the changes introduced in [**PEP 701**](https://peps.python.org/pep-0701/). This means that `STRING` tokens are not emitted any more for f-strings and the tokens described in [**PEP 701**](https://peps.python.org/pep-0701/) are now produced instead: `FSTRING_START`, `FSTRING_MIDDLE` and `FSTRING_END` are now emitted for f-string "string" parts in addition to the appropriate tokens for the tokenization in the expression components. For example for the f-string `f"start {1+1} end"` the old version of the tokenizer emitted:
    
        1,0-1,18:           STRING         'f"start {1+1} end"'
    

而新版本将生成:

    
        1,0-1,2:            FSTRING_START  'f"'
    1,2-1,8:            FSTRING_MIDDLE 'start '
    1,8-1,9:            OP             '{'
    1,9-1,10:           NUMBER         '1'
    1,10-1,11:          OP             '+'
    1,11-1,12:          NUMBER         '1'
    1,12-1,13:          OP             '}'
    1,13-1,17:          FSTRING_MIDDLE ' end'
    1,17-1,18:          FSTRING_END    '"'
    

此外，支持 [**PEP 701**](https://peps.python.org/pep-0701/) 所需的改变还可能会导致一些细微的行为改变。 这些变化包括:

    * 在对一些无效 Python 字符如 `!` 进行分词时相应词元的 `type` 属性已从 `ERRORTOKEN` 变为 `OP`。

    * 不完整的单行字符串现在也会像不完整的多行字符串一样引发 [`tokenize.TokenError`](../library/tokenize.md#tokenize.TokenError "tokenize.TokenError")。

    * 某些不完整或无效的 Python 代码现在会引发 [`tokenize.TokenError`](../library/tokenize.md#tokenize.TokenError "tokenize.TokenError") 而不是在执行分词时返回任意的 `ERRORTOKEN` 词元。

    * 在同一文件中混合使用制表符和空格作为缩进不再受到支持而是会引发 [`TabError`](../library/exceptions.md#TabError "TabError")。

## 构建变化¶

  * Python 不再使用 `setup.py` 来构建共享的 C 扩展模块。 头文件和库等编译参数会在 `configure` 脚本中检测。 扩展将由 `Makefile` 来构建。 大多数扩展使用 `pkg-config` 并回退为手动检测。 （由 Christian Heimes 在 [gh-93939](https://github.com/python/cpython/issues/93939) 中贡献。）

  * 现在需要用带有两个形参的 `va_start()`，如 `va_start(args, format),` 来构建 Python。 现在将不会再调用单个形参的 `va_start()`。 （由 Kumar Aditya 在 [gh-93207](https://github.com/python/cpython/issues/93207) 中贡献。）

  * 现在如果 Clang 编译器接受 ThinLTO 选项则 CPython 会将其作为默认的链接时间优化策略。 （由 Dong-hee Na 在 [gh-89536](https://github.com/python/cpython/issues/89536) 中贡献。）

  * 在 Makefile 中添加了 `COMPILEALL_OPTS` 变量以覆盖 `make install` 中的 [`compileall`](../library/compileall.md#module-compileall "compileall: Tools for byte-compiling all Python source files in a directory tree.") 选项 (默认值: `-j0`)。 并将 3 条 `compileall` 命令合并为单条命令以便一次性构建所有优化级别 (0, 1, 2) 的 .pyc 文件。 （由 Victor Stinner 在 [gh-99289](https://github.com/python/cpython/issues/99289) 中贡献。）

  * 为 64 位 LoongArch 添加了平台三选项:

    * loongarch64-linux-gnusf

    * loongarch64-linux-gnuf32

    * loongarch64-linux-gnu

（由 Zhang Na 在 [gh-90656](https://github.com/python/cpython/issues/90656) 中贡献。）.)

  * `PYTHON_FOR_REGEN` 现在需要 Python 3.10 或更新版本。

  * 现在需要有 autoconf 2.71 和 aclocal 1.16.4 才能重新生成 `!configure`。 （由 Christian Heimes 在 [gh-89886](https://github.com/python/cpython/issues/89886) 中贡献。）

## C API 的变化¶

### 新的特性¶

  * [**PEP 697**](https://peps.python.org/pep-0697/): 引入了 [不稳定 C API 层](../c-api/stable.md#unstable-c-api)，用于调试器和 JIT 编译器等低层级工具。 该 API 可能会在 CPython 的每个次要版本中发生变化而不发出弃用警告。 其内容在名称中会以 `PyUnstable_` 前缀标记。

代码对象构造器:

    * `PyUnstable_Code_New()` (由 `PyCode_New` 改名而来)

    * `PyUnstable_Code_NewWithPosOnlyArgs()` (由 `PyCode_NewWithPosOnlyArgs` 改名而来)

代码对象的额外存储 ([ **PEP 523**](https://peps.python.org/pep-0523/)):

    * `PyUnstable_Eval_RequestCodeExtraIndex()` (由 `_PyEval_RequestCodeExtraIndex` 改名而来)

    * `PyUnstable_Code_GetExtra()` (由 `_PyCode_GetExtra` 改名而来)

    * `PyUnstable_Code_SetExtra()` (由 `_PyCode_SetExtra` 改名而来)

原有名称将继续可用直到对应的 API 发生改变。

（由 Petr Viktorin 在 [gh-101101](https://github.com/python/cpython/issues/101101) 中贡献。）

  * [**PEP 697**](https://peps.python.org/pep-0697/): 添加了用于扩展实例的内存布局不透明的 API:

    * [`PyType_Spec.basicsize`](../c-api/type.md#c.PyType_Spec.basicsize "PyType_Spec.basicsize") 可以为零或负数，用于以指定继承或扩展基类的大小。

    * 增加了 [`PyObject_GetTypeData()`](../c-api/object.md#c.PyObject_GetTypeData "PyObject_GetTypeData") 和 [`PyType_GetTypeDataSize()`](../c-api/object.md#c.PyType_GetTypeDataSize "PyType_GetTypeDataSize") 以允许访问特定子类的实例数据。

    * 添加了 [`Py_TPFLAGS_ITEMS_AT_END`](../c-api/typeobj.md#c.Py_TPFLAGS_ITEMS_AT_END "Py_TPFLAGS_ITEMS_AT_END") 和 [`PyObject_GetItemData()`](../c-api/object.md#c.PyObject_GetItemData "PyObject_GetItemData") 以允许安全地扩展某些可变大小的类型，包括 [`PyType_Type`](../c-api/type.md#c.PyType_Type "PyType_Type")。

    * 添加了 [`Py_RELATIVE_OFFSET`](../c-api/structures.md#c.Py_RELATIVE_OFFSET "Py_RELATIVE_OFFSET") 以允许用特定于子类的结构体来定义 [`成员`](../c-api/structures.md#c.PyMemberDef "PyMemberDef")。

（由 Petr Viktorin 在 [gh-103509](https://github.com/python/cpython/issues/103509) 中贡献。）

  * 添加了新的 [受限 C API](../c-api/stable.md#limited-c-api) 函数 [`PyType_FromMetaclass()`](../c-api/type.md#c.PyType_FromMetaclass "PyType_FromMetaclass")，它使用额外的 metaclass 参数对现有的 [`PyType_FromModuleAndSpec()`](../c-api/type.md#c.PyType_FromModuleAndSpec "PyType_FromModuleAndSpec") 进行了泛化。 （由 Wenzel Jakob 在 [gh-93012](https://github.com/python/cpython/issues/93012) 中贡献。）

  * 在 [受限](../c-api/stable.md#stable) 中添加了用于创建可使用 [vectorcall 协议](../c-api/call.md#vectorcall) 来调用的对象的 API:

    * [`Py_TPFLAGS_HAVE_VECTORCALL`](../c-api/typeobj.md#c.Py_TPFLAGS_HAVE_VECTORCALL "Py_TPFLAGS_HAVE_VECTORCALL")

    * [`PyVectorcall_NARGS()`](../c-api/call.md#c.PyVectorcall_NARGS "PyVectorcall_NARGS")

    * [`PyVectorcall_Call()`](../c-api/call.md#c.PyVectorcall_Call "PyVectorcall_Call")

    * [`vectorcallfunc`](../c-api/call.md#c.vectorcallfunc "vectorcallfunc")

现在当一个类的 [`__call__()`](../reference/datamodel.md#object.__call__ "object.__call__") 方法被重新赋值时，该类的 [`Py_TPFLAGS_HAVE_VECTORCALL`](../c-api/typeobj.md#c.Py_TPFLAGS_HAVE_VECTORCALL "Py_TPFLAGS_HAVE_VECTORCALL") 旗标将被移除。 这使得 vectorcall 可以安全地用于可变类型（即没有不可变旗标 [`Py_TPFLAGS_IMMUTABLETYPE`](../c-api/typeobj.md#c.Py_TPFLAGS_IMMUTABLETYPE "Py_TPFLAGS_IMMUTABLETYPE") 的堆类型）。 未重载 [`tp_call`](../c-api/typeobj.md#c.PyTypeObject.tp_call "PyTypeObject.tp_call") 的可变类型现在继承了 `Py_TPFLAGS_HAVE_VECTORCALL` 旗标。 （由 Petr Viktorin 在 [gh-93274](https://github.com/python/cpython/issues/93274) 中贡献。）

新增了 [`Py_TPFLAGS_MANAGED_DICT`](../c-api/typeobj.md#c.Py_TPFLAGS_MANAGED_DICT "Py_TPFLAGS_MANAGED_DICT") 和 [`Py_TPFLAGS_MANAGED_WEAKREF`](../c-api/typeobj.md#c.Py_TPFLAGS_MANAGED_WEAKREF "Py_TPFLAGS_MANAGED_WEAKREF") 旗标。 这将允许扩展类在支持对象 `__dict__` 和弱引用时减少记录消耗，占用更少内存并并加快访问速度。

  * 在 [受限 API](../c-api/stable.md#stable) 中添加了使用 [vectorcall 协议](../c-api/call.md#vectorcall) 执行调用的 API:

    * [`PyObject_Vectorcall()`](../c-api/call.md#c.PyObject_Vectorcall "PyObject_Vectorcall")

    * [`PyObject_VectorcallMethod()`](../c-api/call.md#c.PyObject_VectorcallMethod "PyObject_VectorcallMethod")

    * [`PY_VECTORCALL_ARGUMENTS_OFFSET`](../c-api/call.md#c.PY_VECTORCALL_ARGUMENTS_OFFSET "PY_VECTORCALL_ARGUMENTS_OFFSET")

这意味着 vectorcall 调用协议的传入端和传出端现在都可以在 [受限 API](../c-api/stable.md#stable) 中使用。 （由 Wenzel Jakob 在 [gh-98586](https://github.com/python/cpython/issues/98586) 中贡献。）

  * 添加了两个新的公共函数 [`PyEval_SetProfileAllThreads()`](../c-api/init.md#c.PyEval_SetProfileAllThreads "PyEval_SetProfileAllThreads") 和 [`PyEval_SetTraceAllThreads()`](../c-api/init.md#c.PyEval_SetTraceAllThreads "PyEval_SetTraceAllThreads")，允许在调用的同时在所有运行线程中设置追踪和性能分析函数。 （由 Pablo Galindo 在 [gh-93503](https://github.com/python/cpython/issues/93503) 贡献。）

  * 为 C API 添加了新函数 [`PyFunction_SetVectorcall()`](../c-api/function.md#c.PyFunction_SetVectorcall "PyFunction_SetVectorcall") 用于设置给定 [`PyFunctionObject`](../c-api/function.md#c.PyFunctionObject "PyFunctionObject") 的 vectorcall 字段。 （由 Andrew Frost 在 [gh-92257](https://github.com/python/cpython/issues/92257) 中贡献。）

  * C API 现在允许通过 [`PyDict_AddWatcher()`](../c-api/dict.md#c.PyDict_AddWatcher "PyDict_AddWatcher")、[`PyDict_Watch()`](../c-api/dict.md#c.PyDict_Watch "PyDict_Watch") 和相关 API 注册回调，以便在字典被修改时调用。 这主要用于优化解释器、JIT 编译器或调试器。 （由 Carl Meyer 在 [gh-91052](https://github.com/python/cpython/issues/91052) 中贡献。）

  * 添加了 [`PyType_AddWatcher()`](../c-api/type.md#c.PyType_AddWatcher "PyType_AddWatcher") 和 [`PyType_Watch()`](../c-api/type.md#c.PyType_Watch "PyType_Watch") API 用于注册回调以接收类型变更通知。 （由 Carl Meyer 在 [gh-91051](https://github.com/python/cpython/issues/91051) 中贡献。）

  * 添加了 [`PyCode_AddWatcher()`](../c-api/code.md#c.PyCode_AddWatcher "PyCode_AddWatcher") 和 [`PyCode_ClearWatcher()`](../c-api/code.md#c.PyCode_ClearWatcher "PyCode_ClearWatcher") API 用于注册回调以接收代码对象创建和销毁时的通知。 （由 Itamar Ostricher 在 [gh-91054](https://github.com/python/cpython/issues/91054) 中贡献。）

  * 添加了 [`PyFrame_GetVar()`](../c-api/frame.md#c.PyFrame_GetVar "PyFrame_GetVar") 和 [`PyFrame_GetVarString()`](../c-api/frame.md#c.PyFrame_GetVarString "PyFrame_GetVarString") 函数用于通过名称来获取帧变量。 （由 Victor Stinner 在 [gh-91248](https://github.com/python/cpython/issues/91248) 中贡献。）

  * 添加 [`PyErr_GetRaisedException()`](../c-api/exceptions.md#c.PyErr_GetRaisedException "PyErr_GetRaisedException") 和 [`PyErr_SetRaisedException()`](../c-api/exceptions.md#c.PyErr_SetRaisedException "PyErr_SetRaisedException") 用于保存和恢复当前异常。 这些函数返回并接受单个异常对象，而不是像现在已弃用的 [`PyErr_Fetch()`](../c-api/exceptions.md#c.PyErr_Fetch "PyErr_Fetch") 和 [`PyErr_Restore()`](../c-api/exceptions.md#c.PyErr_Restore "PyErr_Restore") 那样的三个参数。 这样不容易出错并且更为高效。 （由 Mark Shannon 在 [gh-101578](https://github.com/python/cpython/issues/101578) 中贡献。）

  * 添加了 `_PyErr_ChainExceptions1`，它接受一个异常实例，用于取代旧式 API `_PyErr_ChainExceptions`，后者现已被弃用。 （由 Mark Shannon 在 [gh-101578](https://github.com/python/cpython/issues/101578) 中贡献。）

  * 添加了 [`PyException_GetArgs()`](../c-api/exceptions.md#c.PyException_GetArgs "PyException_GetArgs") 和 [`PyException_SetArgs()`](../c-api/exceptions.md#c.PyException_SetArgs "PyException_SetArgs") 作为便捷函数用于检索和修改传递给异常的构造函数的 [`args`](../library/exceptions.md#BaseException.args "BaseException.args")。 （由 Mark Shannon 在 [gh-101578](https://github.com/python/cpython/issues/101578) 中贡献。）

  * 添加了 [`PyErr_DisplayException()`](../c-api/exceptions.md#c.PyErr_DisplayException "PyErr_DisplayException")，它接受一个异常实例，用于取代旧式 API `PyErr_Display()`。 （由 Irit Katriel 在 [gh-102755](https://github.com/python/cpython/issues/102755) 中贡献。）

  * [**PEP 683**](https://peps.python.org/pep-0683/): 在 Python 中引入了永生对象，它允许对象绕过引用计数，并对 C-API 进行了相应修改:

    * `_Py_IMMORTAL_REFCNT`: 定义对象的引用计数
    

为永生对象。

    * `_Py_IsImmortal` 检测一个对象是否具有永生引用计数。

    * `PyObject_HEAD_INIT` 这将把引用计数初始化为
    

`_Py_IMMORTAL_REFCNT` 当配合 `Py_BUILD_CORE` 使用时。

    * `SSTATE_INTERNED_IMMORTAL` 一个针对内部 unicode 对象的标识符
    

为永生对象。

    * `SSTATE_INTERNED_IMMORTAL_STATIC` 一个针对内部 unicode
    

为永生且静态的对象

    * `sys.getunicodeinternedsize` 这将返回总计的 unicode
    

被管理的对象。 现在 refleak.py 需要这样才能正确地追踪引用计数和分配的块

（由 Eddie Elizondo 在 [gh-84436](https://github.com/python/cpython/issues/84436) 中贡献。）

  * [**PEP 684**](https://peps.python.org/pep-0684/): 新增了 [`Py_NewInterpreterFromConfig()`](../c-api/init.md#c.Py_NewInterpreterFromConfig "Py_NewInterpreterFromConfig") 函数和 [`PyInterpreterConfig`](../c-api/init.md#c.PyInterpreterConfig "PyInterpreterConfig")，可用于创建具有单独 GIL 的子解释器。 （更多信息参见 PEP 684: 解释器级 GIL。） （由 Eric Snow 在 [gh-104110](https://github.com/python/cpython/issues/104110) 中贡献。）

  * 在 3.12 版的受限 C API 中，[`Py_INCREF()`](../c-api/refcounting.md#c.Py_INCREF "Py_INCREF") 和 [`Py_DECREF()`](../c-api/refcounting.md#c.Py_DECREF "Py_DECREF") 函数现在使用不透明函数调用的方式实现以隐藏实现细节。 （由 Victor Stinner 在 [gh-105387](https://github.com/python/cpython/issues/105387) 中贡献。）

### 移植到 Python 3.12¶

  * 基于 `Py_UNICODE*` 表示形式的旧式 Unicode API 已被移除。 请迁移到基于 UTF-8 或 `wchar_t*` 的 API。

  * [`PyArg_ParseTuple()`](../c-api/arg.md#c.PyArg_ParseTuple "PyArg_ParseTuple") 等参数解析函数不再支持基于 `Py_UNICODE*` 的格式（例如 `u`, `Z` 等）。 请迁移到其他 Unicode 格式如 `s`, `z`, `es` 和 `U`。

  * `tp_weaklist` 对于所有静态内置类型将始终为 `NULL`。 这是 `PyTypeObject` 上的一个内部专属字段，但我们还是要指出这一变化以防有人碰巧仍然直接访问到该字段。 为避免出现中断，请考虑改用现有的公共 C-API，或在必要时使用（仅限内部使用的）宏 `_PyObject_GET_WEAKREFS_LISTPTR()`。

  * 现在这个内部专用的 [`PyTypeObject.tp_subclasses`](../c-api/typeobj.md#c.PyTypeObject.tp_subclasses "PyTypeObject.tp_subclasses") 可能不是一个有效的对象指针。 为了反映这一点我们将其类型改为 void*。 我们提到这一点是为了防止有人碰巧直接访问到这个内部专用字段。

要获取子类的列表，请调用 Python 方法 [`__subclasses__()`](../library/stdtypes.md#class.__subclasses__ "class.__subclasses__") (例如使用 [`PyObject_CallMethod()`](../c-api/call.md#c.PyObject_CallMethod "PyObject_CallMethod"))。

  * 在 [`PyUnicode_FromFormat()`](../c-api/unicode.md#c.PyUnicode_FromFormat "PyUnicode_FromFormat") 和 [`PyUnicode_FromFormatV()`](../c-api/unicode.md#c.PyUnicode_FromFormatV "PyUnicode_FromFormatV") 中添加对更多格式选项（左对齐、八进制、大写十六进制、`intmax_t`、`ptrdiff_t`、`wchar_t` C 字符串、可变宽度和精度）的支持。 （由 Serhiy Storchaka 在 [gh-98836](https://github.com/python/cpython/issues/98836) 中贡献。）

  * [`PyUnicode_FromFormat()`](../c-api/unicode.md#c.PyUnicode_FromFormat "PyUnicode_FromFormat") 和 [`PyUnicode_FromFormatV()`](../c-api/unicode.md#c.PyUnicode_FromFormatV "PyUnicode_FromFormatV") 中未被识别的格式字符现在会设置一个 [`SystemError`](../library/exceptions.md#SystemError "SystemError")。 在之前的版本中它会导致格式字符串的所有其他部分被原样复制到结果字符串中，并丢弃任何额外的参数。 （由 Serhiy Storchaka 在 [gh-95781](https://github.com/python/cpython/issues/95781) 中贡献。）

  * 修复了 [`PyUnicode_FromFormat()`](../c-api/unicode.md#c.PyUnicode_FromFormat "PyUnicode_FromFormat") 和 [`PyUnicode_FromFormatV()`](../c-api/unicode.md#c.PyUnicode_FromFormatV "PyUnicode_FromFormatV") 中错误的标志位置。 （由 Philip Georgi 在 [gh-95504](https://github.com/python/cpython/issues/95504) 中贡献。）

  * 希望添加 `__dict__` 或弱引用槽位的扩展类应分别使用 [`Py_TPFLAGS_MANAGED_DICT`](../c-api/typeobj.md#c.Py_TPFLAGS_MANAGED_DICT "Py_TPFLAGS_MANAGED_DICT") 和 [`Py_TPFLAGS_MANAGED_WEAKREF`](../c-api/typeobj.md#c.Py_TPFLAGS_MANAGED_WEAKREF "Py_TPFLAGS_MANAGED_WEAKREF") 来代替 `tp_dictoffset` 和 `tp_weaklistoffset`。 目前仍支持使用 `tp_dictoffset` 和 `tp_weaklistoffset`，但并不完全支持多重继承 ([gh-95589](https://github.com/python/cpython/issues/95589))，而且性能可能会变差。 声明了 [`Py_TPFLAGS_MANAGED_DICT`](../c-api/typeobj.md#c.Py_TPFLAGS_MANAGED_DICT "Py_TPFLAGS_MANAGED_DICT") 的类应当调用 `_PyObject_VisitManagedDict()` 和 `_PyObject_ClearManagedDict()` 来遍历并清除它们的实例的字典。 要清除弱引用，请像之前一样调用 [`PyObject_ClearWeakRefs()`](../c-api/weakref.md#c.PyObject_ClearWeakRefs "PyObject_ClearWeakRefs")。

  * [`PyUnicode_FSDecoder()`](../c-api/unicode.md#c.PyUnicode_FSDecoder "PyUnicode_FSDecoder") 函数不再接受类似字节串的路径，如 [`bytearray`](../library/stdtypes.md#bytearray "bytearray") 和 [`memoryview`](../library/stdtypes.md#memoryview "memoryview") 类型：只接受明确的 [`bytes`](../library/stdtypes.md#bytes "bytes") 类型字节字符串。 （由 Victor Stinner 在 [gh-98393](https://github.com/python/cpython/issues/98393) 中贡献。）

  * [`Py_CLEAR`](../c-api/refcounting.md#c.Py_CLEAR "Py_CLEAR")、[`Py_SETREF`](../c-api/refcounting.md#c.Py_SETREF "Py_SETREF") 和 [`Py_XSETREF`](../c-api/refcounting.md#c.Py_XSETREF "Py_XSETREF") 宏现在只会对其参数求值一次。如果参数有附带影响，这些附带影响将不会再重复。 （由 Victor Stinner 在 [gh-98724](https://github.com/python/cpython/issues/98724) 中贡献。）

  * 解释器的错误指示器现在总是规范化的。 这意味着 [`PyErr_SetObject()`](../c-api/exceptions.md#c.PyErr_SetObject "PyErr_SetObject")、[`PyErr_SetString()`](../c-api/exceptions.md#c.PyErr_SetString "PyErr_SetString") 以及其他设置错误指示器的函数在保存异常之前都会将其规范化。 （由 Mark Shannon 在 [gh-101578](https://github.com/python/cpython/issues/101578) 中贡献。）

  * `_Py_RefTotal` 已不再具有重要性而保留它只是为了 ABI 的兼容性。 请注意，这是一个内部全局变量并且仅在调试版本中可用。 如果你碰巧要使用它那么你需要开始使用 `_Py_GetGlobalRefTotal()`。

  * 下面的函数将为新创建的类型选择一个合适的元类:

    * [`PyType_FromSpec()`](../c-api/type.md#c.PyType_FromSpec "PyType_FromSpec")

    * [`PyType_FromSpecWithBases()`](../c-api/type.md#c.PyType_FromSpecWithBases "PyType_FromSpecWithBases")

    * [`PyType_FromModuleAndSpec()`](../c-api/type.md#c.PyType_FromModuleAndSpec "PyType_FromModuleAndSpec")

创建具有重载了 [`tp_new`](../c-api/typeobj.md#c.PyTypeObject.tp_new "PyTypeObject.tp_new") 的元类的类的做法已被弃用，在 Python 3.14+ 中将被禁止。 请注意这些函数会忽略元类的 `tp_new`，从而可能导致不完整的初始化。

请注意 [`PyType_FromMetaclass()`](../c-api/type.md#c.PyType_FromMetaclass "PyType_FromMetaclass") (在 Python 3.12 中新增) 已禁止创建具有重载了 `tp_new` (在 Python 中为 [`__new__()`](../reference/datamodel.md#object.__new__ "object.__new__") ) 的元类的类。

由于 `tp_new` 重载了``PyType_From*`` 函数的几乎所有内容，因此两者互不兼容。 现有的行为 -- 在创建类型的一些步骤中忽略元类 -- 通常都是不安全的，因为（元）类会假定 `tp_new` 已被调用。 目前还没有简单通用的绕过方式。 以下办法之一可能对你有用:

    * 如果你控制着元类，请避免在其中使用 `tp_new`:

      * 如初始化可被跳过，则可以改在 [`tp_init`](../c-api/typeobj.md#c.PyTypeObject.tp_init "PyTypeObject.tp_init") 中完成。

      * 如果元类不需要从 Python 执行实例化，则使用 [`Py_TPFLAGS_DISALLOW_INSTANTIATION`](../c-api/typeobj.md#c.Py_TPFLAGS_DISALLOW_INSTANTIATION "Py_TPFLAGS_DISALLOW_INSTANTIATION") 旗标将其 `tp_new` 设为 `NULL`。 这将使其可被 `PyType_From*` 函数接受。

    * 避免使用 `PyType_From*` 函数：如果不需要 C 专属的特性（槽位或设置实例大小），请通过 [调用](../c-api/call.md#call) 元类来创建类型。

    * 如果你 _知道_ 可以安全地跳过 `tp_new`，就使用 Python 中的 [`warnings.catch_warnings()`](../library/warnings.md#warnings.catch_warnings "warnings.catch_warnings") 过滤掉弃用警告。

  * [`PyOS_InputHook`](../c-api/veryhigh.md#c.PyOS_InputHook "PyOS_InputHook") 和 [`PyOS_ReadlineFunctionPointer`](../c-api/veryhigh.md#c.PyOS_ReadlineFunctionPointer "PyOS_ReadlineFunctionPointer") 将不再在 [子解释器](../c-api/init.md#sub-interpreter-support) 中被调用。 这是因为客户端通常依赖进程级的全局状态（而这些回调没有办法恢复扩展模块状态）。

这也避免了扩展程序在不支持（或尚未被加载）的子解释器中运行的情况。 请参阅 [gh-104668](https://github.com/python/cpython/issues/104668) 了解更多信息。

  * [`PyLongObject`](../c-api/long.md#c.PyLongObject "PyLongObject") 对其内部字段进行了修改以提高性能。 虽然 [`PyLongObject`](../c-api/long.md#c.PyLongObject "PyLongObject") 的内部字段是私有的，但某些扩展模块会使用它们。 内部字段不应再被直接访问，而应改用以 `PyLong_...` 打头的 API 函数。 新增了两个 _暂定_ API 函数用于高效访问适配至单个机器字的 [`PyLongObject`](../c-api/long.md#c.PyLongObject "PyLongObject") 的值:

    * [`PyUnstable_Long_IsCompact()`](../c-api/long.md#c.PyUnstable_Long_IsCompact "PyUnstable_Long_IsCompact")

    * [`PyUnstable_Long_CompactValue()`](../c-api/long.md#c.PyUnstable_Long_CompactValue "PyUnstable_Long_CompactValue")

  * 通过 [`PyMem_SetAllocator()`](../c-api/memory.md#c.PyMem_SetAllocator "PyMem_SetAllocator") 设置的自定义分配器现在必须是线程安全的，无论内存域是什么。 没有自己的状态的分配器，包括“钩子”将不会受影响。 如果你的自定义分配器还不是线程安全的且你需要指导则请创建一个新的 GitHub 问题并抄送给 `@ericsnowcurrently`。

### 弃用¶

  * 已弃用的全局配置变量:

    * [`Py_DebugFlag`](../c-api/init.md#c.Py_DebugFlag "Py_DebugFlag"): 使用 [`PyConfig.parser_debug`](../c-api/init_config.md#c.PyConfig.parser_debug "PyConfig.parser_debug")

    * [`Py_VerboseFlag`](../c-api/init.md#c.Py_VerboseFlag "Py_VerboseFlag"): 使用 [`PyConfig.verbose`](../c-api/init_config.md#c.PyConfig.verbose "PyConfig.verbose")

    * [`Py_QuietFlag`](../c-api/init.md#c.Py_QuietFlag "Py_QuietFlag"): 使用 [`PyConfig.quiet`](../c-api/init_config.md#c.PyConfig.quiet "PyConfig.quiet")

    * [`Py_InteractiveFlag`](../c-api/init.md#c.Py_InteractiveFlag "Py_InteractiveFlag"): 使用 [`PyConfig.interactive`](../c-api/init_config.md#c.PyConfig.interactive "PyConfig.interactive")

    * [`Py_InspectFlag`](../c-api/init.md#c.Py_InspectFlag "Py_InspectFlag"): 使用 [`PyConfig.inspect`](../c-api/init_config.md#c.PyConfig.inspect "PyConfig.inspect")

    * [`Py_OptimizeFlag`](../c-api/init.md#c.Py_OptimizeFlag "Py_OptimizeFlag"): 使用 [`PyConfig.optimization_level`](../c-api/init_config.md#c.PyConfig.optimization_level "PyConfig.optimization_level")

    * [`Py_NoSiteFlag`](../c-api/init.md#c.Py_NoSiteFlag "Py_NoSiteFlag"): 使用 [`PyConfig.site_import`](../c-api/init_config.md#c.PyConfig.site_import "PyConfig.site_import")

    * [`Py_BytesWarningFlag`](../c-api/init.md#c.Py_BytesWarningFlag "Py_BytesWarningFlag"): 使用 [`PyConfig.bytes_warning`](../c-api/init_config.md#c.PyConfig.bytes_warning "PyConfig.bytes_warning")

    * [`Py_FrozenFlag`](../c-api/init.md#c.Py_FrozenFlag "Py_FrozenFlag"): 使用 [`PyConfig.pathconfig_warnings`](../c-api/init_config.md#c.PyConfig.pathconfig_warnings "PyConfig.pathconfig_warnings")

    * [`Py_IgnoreEnvironmentFlag`](../c-api/init.md#c.Py_IgnoreEnvironmentFlag "Py_IgnoreEnvironmentFlag"): 使用 [`PyConfig.use_environment`](../c-api/init_config.md#c.PyConfig.use_environment "PyConfig.use_environment")

    * [`Py_DontWriteBytecodeFlag`](../c-api/init.md#c.Py_DontWriteBytecodeFlag "Py_DontWriteBytecodeFlag"): 使用 [`PyConfig.write_bytecode`](../c-api/init_config.md#c.PyConfig.write_bytecode "PyConfig.write_bytecode")

    * [`Py_NoUserSiteDirectory`](../c-api/init.md#c.Py_NoUserSiteDirectory "Py_NoUserSiteDirectory"): 使用 [`PyConfig.user_site_directory`](../c-api/init_config.md#c.PyConfig.user_site_directory "PyConfig.user_site_directory")

    * [`Py_UnbufferedStdioFlag`](../c-api/init.md#c.Py_UnbufferedStdioFlag "Py_UnbufferedStdioFlag"): 使用 [`PyConfig.buffered_stdio`](../c-api/init_config.md#c.PyConfig.buffered_stdio "PyConfig.buffered_stdio")

    * [`Py_HashRandomizationFlag`](../c-api/init.md#c.Py_HashRandomizationFlag "Py_HashRandomizationFlag"): 使用 [`PyConfig.use_hash_seed`](../c-api/init_config.md#c.PyConfig.use_hash_seed "PyConfig.use_hash_seed") 和 [`PyConfig.hash_seed`](../c-api/init_config.md#c.PyConfig.hash_seed "PyConfig.hash_seed")

    * [`Py_IsolatedFlag`](../c-api/init.md#c.Py_IsolatedFlag "Py_IsolatedFlag"): 使用 [`PyConfig.isolated`](../c-api/init_config.md#c.PyConfig.isolated "PyConfig.isolated")

    * [`Py_LegacyWindowsFSEncodingFlag`](../c-api/init.md#c.Py_LegacyWindowsFSEncodingFlag "Py_LegacyWindowsFSEncodingFlag"): 使用 [`PyPreConfig.legacy_windows_fs_encoding`](../c-api/init_config.md#c.PyPreConfig.legacy_windows_fs_encoding "PyPreConfig.legacy_windows_fs_encoding")

    * [`Py_LegacyWindowsStdioFlag`](../c-api/init.md#c.Py_LegacyWindowsStdioFlag "Py_LegacyWindowsStdioFlag"): 使用 [`PyConfig.legacy_windows_stdio`](../c-api/init_config.md#c.PyConfig.legacy_windows_stdio "PyConfig.legacy_windows_stdio")

    * `Py_FileSystemDefaultEncoding`: 使用 [`PyConfig.filesystem_encoding`](../c-api/init_config.md#c.PyConfig.filesystem_encoding "PyConfig.filesystem_encoding")

    * `Py_HasFileSystemDefaultEncoding`: 使用 [`PyConfig.filesystem_encoding`](../c-api/init_config.md#c.PyConfig.filesystem_encoding "PyConfig.filesystem_encoding")

    * `Py_FileSystemDefaultEncodeErrors`: 使用 [`PyConfig.filesystem_errors`](../c-api/init_config.md#c.PyConfig.filesystem_errors "PyConfig.filesystem_errors")

    * `Py_UTF8Mode`: 使用 [`PyPreConfig.utf8_mode`](../c-api/init_config.md#c.PyPreConfig.utf8_mode "PyPreConfig.utf8_mode") (参见 [`Py_PreInitialize()`](../c-api/init_config.md#c.Py_PreInitialize "Py_PreInitialize"))

[`Py_InitializeFromConfig()`](../c-api/init_config.md#c.Py_InitializeFromConfig "Py_InitializeFromConfig") API 应当改为使用 [`PyConfig`](../c-api/init_config.md#c.PyConfig "PyConfig")。 （由 Victor Stinner 在 [gh-77782](https://github.com/python/cpython/issues/77782) 中贡献。）

  * 使用可变基类创建不可变类型 ([`Py_TPFLAGS_IMMUTABLETYPE`](../c-api/typeobj.md#c.Py_TPFLAGS_IMMUTABLETYPE "Py_TPFLAGS_IMMUTABLETYPE")) 的做法已被弃用并将在 Python 3.14 中禁用。

  * `structmember.h` 头文件已被弃用，不过它仍可继续使用也没有计划将其移除。

现在只需包括 `Python.h` 即可获得其内容，如果找不到请添加 `Py` 前缀:

    * [`PyMemberDef`](../c-api/structures.md#c.PyMemberDef "PyMemberDef"), [`PyMember_GetOne()`](../c-api/structures.md#c.PyMember_GetOne "PyMember_GetOne") 和 [`PyMember_SetOne()`](../c-api/structures.md#c.PyMember_SetOne "PyMember_SetOne")

    * 类型宏如 [`Py_T_INT`](../c-api/structures.md#c.Py_T_INT "Py_T_INT"), [`Py_T_DOUBLE`](../c-api/structures.md#c.Py_T_DOUBLE "Py_T_DOUBLE") 等（之前为 `T_INT`, `T_DOUBLE` 等）

    * 旗标 [`Py_READONLY`](../c-api/structures.md#c.Py_READONLY "Py_READONLY") (之前为 `READONLY`) 和 [`Py_AUDIT_READ`](../c-api/structures.md#c.Py_AUDIT_READ "Py_AUDIT_READ") (之前为全大写形式)

部分条目未从 `Python.h` 对外公开:

    * [`T_OBJECT`](../c-api/structures.md#c.T_OBJECT "T_OBJECT") (使用 [`Py_T_OBJECT_EX`](../c-api/structures.md#c.Py_T_OBJECT_EX "Py_T_OBJECT_EX"))

    * [`T_NONE`](../c-api/structures.md#c.T_NONE "T_NONE") (之前未写入文档，并且相当怪异)

    * 不进行任何操作的宏 `WRITE_RESTRICTED`。

    * `RESTRICTED` 和 `READ_RESTRICTED` 宏，等同于 [`Py_AUDIT_READ`](../c-api/structures.md#c.Py_AUDIT_READ "Py_AUDIT_READ")。

    * 在某些配置中，`Python.h` 未被 `<stddef.h>` 包括。 在使用 `offsetof()` 时应当手动包括它。

已被弃用的头文件将继续以原来的名称提供原来的内容。 你的旧代码可以保持不变，除非额外的包括指令和无命名空间宏会给你带来很大困扰。

（由 Petr Viktorin 在 [gh-47146](https://github.com/python/cpython/issues/47146) 中贡献，基于 Alexander Belopolsky 和 Matthias Braun 在先前的工作。）.)

  * [`PyErr_Fetch()`](../c-api/exceptions.md#c.PyErr_Fetch "PyErr_Fetch") 和 [`PyErr_Restore()`](../c-api/exceptions.md#c.PyErr_Restore "PyErr_Restore") 已被弃用。请使用 [`PyErr_GetRaisedException()`](../c-api/exceptions.md#c.PyErr_GetRaisedException "PyErr_GetRaisedException") 和 [`PyErr_SetRaisedException()`](../c-api/exceptions.md#c.PyErr_SetRaisedException "PyErr_SetRaisedException") 代替。(由 Mark Shannon 在:gh:101578 贡献）。

  * `PyErr_Display()` 已被弃用，请改用 [`PyErr_DisplayException()`](../c-api/exceptions.md#c.PyErr_DisplayException "PyErr_DisplayException")。 （由 Irit Katriel 在 [gh-102755](https://github.com/python/cpython/issues/102755) 中贡献。）

  * `_PyErr_ChainExceptions` 已被弃用。 请改用 `_PyErr_ChainExceptions1`。 （由 Irit Katriel 在 [gh-102192](https://github.com/python/cpython/issues/102192) 中贡献。）

  * 使用 [`PyType_FromSpec()`](../c-api/type.md#c.PyType_FromSpec "PyType_FromSpec"), [`PyType_FromSpecWithBases()`](../c-api/type.md#c.PyType_FromSpecWithBases "PyType_FromSpecWithBases") 或 [`PyType_FromModuleAndSpec()`](../c-api/type.md#c.PyType_FromModuleAndSpec "PyType_FromModuleAndSpec") 来创建所属元类重载了 [`tp_new`](../c-api/typeobj.md#c.PyTypeObject.tp_new "PyTypeObject.tp_new") 的类的做法已被弃用。 请改为调用相应元类。is deprecated. Call the metaclass instead.

### 移除¶

  * 移除了 `token.h` 头文件。 从来就没有任何公用的分词器 C API。 `token.h` 头文件只是为 Python 内部使用而设计的。 （由 Victor Stinner 在 [gh-92651](https://github.com/python/cpython/issues/92651) 中贡献。）

  * 旧式 Unicode API 已被移除。 请参阅 [**PEP 623**](https://peps.python.org/pep-0623/) 了解详情。for detail.

>     * `PyUnicode_WCHAR_KIND`
>
>     * `PyUnicode_AS_UNICODE()`
>
>     * `PyUnicode_AsUnicode()`
>
>     * `PyUnicode_AsUnicodeAndSize()`
>
>     * `PyUnicode_AS_DATA()`
>
>     * `PyUnicode_FromUnicode()`
>
>     * `PyUnicode_GET_SIZE()`
>
>     * `PyUnicode_GetSize()`
>
>     * `PyUnicode_GET_DATA_SIZE()`

  * 移除了 `PyUnicode_InternImmortal()` 函数宏。 （由 Victor Stinner 在 [gh-85858](https://github.com/python/cpython/issues/85858) 中贡献。）.)

  * 从多个标准库模块和测试中移除了 `Jython` 兼容性处理。 （由 Nikita Sobolev 在 [gh-99482](https://github.com/python/cpython/issues/99482) 中贡献。）

  * 从 [`ctypes`](../library/ctypes.md#module-ctypes "ctypes: A foreign function library for Python.") 模块移除了 `_use_broken_old_ctypes_structure_semantics_` 旗标。 （由 Nikita Sobolev 在 [gh-99285](https://github.com/python/cpython/issues/99285) 中贡献。）

